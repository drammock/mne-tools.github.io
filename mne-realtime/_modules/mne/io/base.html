

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mne.io.base &mdash; MNE-Realtime 0.0.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/project-template.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> MNE-Realtime
          

          
            
            <img src="../../../_static/mne_logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User guide: create your own mne project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">mne-realtime API</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial - Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Real-time M/EEG Acquisition</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MNE-Realtime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mne.io.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mne.io.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Matti Hamalainen &lt;msh@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Martin Luessi &lt;mluessi@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Denis Engemann &lt;denis.engemann@gmail.com&gt;</span>
<span class="c1">#          Teon Brooks &lt;teon.brooks@gmail.com&gt;</span>
<span class="c1">#          Marijn van Vliet &lt;w.m.vanvliet@gmail.com&gt;</span>
<span class="c1">#          Stefan Appelhoff &lt;stefan.appelhoff@mailbox.org&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.constants</span> <span class="k">import</span> <span class="n">FIFF</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">_construct_bids_filename</span><span class="p">,</span> <span class="n">_check_orig_units</span>
<span class="kn">from</span> <span class="nn">.pick</span> <span class="k">import</span> <span class="p">(</span><span class="n">pick_types</span><span class="p">,</span> <span class="n">channel_type</span><span class="p">,</span> <span class="n">pick_channels</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">,</span>
                   <span class="n">_picks_to_idx</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.meas_info</span> <span class="k">import</span> <span class="n">write_meas_info</span>
<span class="kn">from</span> <span class="nn">.proj</span> <span class="k">import</span> <span class="n">setup_proj</span><span class="p">,</span> <span class="n">activate_proj</span><span class="p">,</span> <span class="n">_proj_equal</span><span class="p">,</span> <span class="n">ProjMixin</span>
<span class="kn">from</span> <span class="nn">..channels.channels</span> <span class="k">import</span> <span class="p">(</span><span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span>
                                 <span class="n">SetChannelsMixin</span><span class="p">,</span> <span class="n">InterpolationMixin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..channels.montage</span> <span class="k">import</span> <span class="n">read_montage</span><span class="p">,</span> <span class="n">_set_montage</span><span class="p">,</span> <span class="n">Montage</span>
<span class="kn">from</span> <span class="nn">.compensator</span> <span class="k">import</span> <span class="n">set_current_comp</span><span class="p">,</span> <span class="n">make_compensator</span>
<span class="kn">from</span> <span class="nn">.write</span> <span class="k">import</span> <span class="p">(</span><span class="n">start_file</span><span class="p">,</span> <span class="n">end_file</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">end_block</span><span class="p">,</span>
                    <span class="n">write_dau_pack16</span><span class="p">,</span> <span class="n">write_float</span><span class="p">,</span> <span class="n">write_double</span><span class="p">,</span>
                    <span class="n">write_complex64</span><span class="p">,</span> <span class="n">write_complex128</span><span class="p">,</span> <span class="n">write_int</span><span class="p">,</span>
                    <span class="n">write_id</span><span class="p">,</span> <span class="n">write_string</span><span class="p">,</span> <span class="n">_get_split_size</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..annotations</span> <span class="k">import</span> <span class="p">(</span><span class="n">_annotations_starts_stops</span><span class="p">,</span> <span class="n">_write_annotations</span><span class="p">,</span>
                           <span class="n">_handle_meas_date</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..filter</span> <span class="k">import</span> <span class="p">(</span><span class="n">filter_data</span><span class="p">,</span> <span class="n">notch_filter</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span>
                      <span class="n">_resample_stim_channels</span><span class="p">,</span> <span class="n">_filt_check_picks</span><span class="p">,</span>
                      <span class="n">_filt_update_info</span><span class="p">,</span> <span class="n">_check_fun</span><span class="p">,</span> <span class="n">HilbertMixin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..parallel</span> <span class="k">import</span> <span class="n">parallel_func</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">_check_fname</span><span class="p">,</span> <span class="n">_check_pandas_installed</span><span class="p">,</span> <span class="n">sizeof_fmt</span><span class="p">,</span>
                     <span class="n">_check_pandas_index_arguments</span><span class="p">,</span> <span class="n">_pl</span><span class="p">,</span> <span class="n">fill_doc</span><span class="p">,</span>
                     <span class="n">check_fname</span><span class="p">,</span> <span class="n">_get_stim_channel</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">,</span>
                     <span class="n">logger</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">_time_mask</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">,</span>
                     <span class="n">copy_function_doc_to_method_doc</span><span class="p">,</span>
                     <span class="n">_check_preload</span><span class="p">,</span> <span class="n">_get_argvalues</span><span class="p">,</span> <span class="n">_check_option</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..viz</span> <span class="k">import</span> <span class="n">plot_raw</span><span class="p">,</span> <span class="n">plot_raw_psd</span><span class="p">,</span> <span class="n">plot_raw_psd_topo</span>
<span class="kn">from</span> <span class="nn">..defaults</span> <span class="k">import</span> <span class="n">_handle_default</span>
<span class="kn">from</span> <span class="nn">..event</span> <span class="k">import</span> <span class="n">find_events</span><span class="p">,</span> <span class="n">concatenate_events</span>
<span class="kn">from</span> <span class="nn">..annotations</span> <span class="k">import</span> <span class="n">Annotations</span><span class="p">,</span> <span class="n">_combine_annotations</span><span class="p">,</span> <span class="n">_sync_onset</span>
<span class="kn">from</span> <span class="nn">..annotations</span> <span class="k">import</span> <span class="n">_ensure_annotation_object</span>


<span class="k">def</span> <span class="nf">_set_pandas_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to set the right columns to dtype.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Converting &quot;</span><span class="si">%s</span><span class="s1">&quot; to &quot;</span><span class="si">%s</span><span class="s1">&quot;...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">ToDataFrameMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to add to_data_frame capabilities to certain classes.&quot;&quot;&quot;</span>

    <span class="nd">@fill_doc</span>
    <span class="k">def</span> <span class="nf">to_data_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scaling_time</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span>
                      <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">long_format</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export data in tabular structure as a pandas DataFrame.</span>

<span class="sd">        Columns and indices will depend on the object being converted.</span>
<span class="sd">        Generally this will include as much relevant information as</span>
<span class="sd">        possible for the data type being converted. This makes it easy</span>
<span class="sd">        to convert data for use in packages that utilize dataframes,</span>
<span class="sd">        such as statsmodels or seaborn.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(picks_all)s</span>
<span class="sd">        index : tuple of str | None</span>
<span class="sd">            Column to be used as index for the data. Valid string options</span>
<span class="sd">            are &#39;epoch&#39;, &#39;time&#39; and &#39;condition&#39;. If None, all three info</span>
<span class="sd">            columns will be included in the table as categorial data.</span>
<span class="sd">        scaling_time : float</span>
<span class="sd">            Scaling to be applied to time units.</span>
<span class="sd">        scalings : dict | None</span>
<span class="sd">            Scaling to be applied to the channels picked. If None, defaults to</span>
<span class="sd">            ``scalings=dict(eeg=1e6, grad=1e13, mag=1e15, misc=1.0)``.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            If true, data will be copied. Else data may be modified in place.</span>
<span class="sd">        start : int | None</span>
<span class="sd">            If it is a Raw object, this defines a starting index for creating</span>
<span class="sd">            the dataframe from a slice. The times will be interpolated from the</span>
<span class="sd">            index and the sampling rate of the signal.</span>
<span class="sd">        stop : int | None</span>
<span class="sd">            If it is a Raw object, this defines a stop index for creating</span>
<span class="sd">            the dataframe from a slice. The times will be interpolated from the</span>
<span class="sd">            index and the sampling rate of the signal.</span>
<span class="sd">        long_format : bool</span>
<span class="sd">            If True, the dataframe is returned in long format where each row</span>
<span class="sd">            is one observation of the signal at a unique coordinate of</span>
<span class="sd">            channels, time points, epochs and conditions. The number of</span>
<span class="sd">            factors depends on the data container. For convenience,</span>
<span class="sd">            a `ch_type` column is added when using this option that will</span>
<span class="sd">            facilitate subsetting the resulting dataframe.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : instance of pandas.DataFrame</span>
<span class="sd">            A dataframe suitable for usage with other</span>
<span class="sd">            statistical/plotting/analysis packages. Column/Index values will</span>
<span class="sd">            depend on the object type being converted, but should be</span>
<span class="sd">            human-readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>
        <span class="kn">from</span> <span class="nn">..evoked</span> <span class="k">import</span> <span class="n">Evoked</span>
        <span class="kn">from</span> <span class="nn">..source_estimate</span> <span class="k">import</span> <span class="n">_BaseSourceEstimate</span>

        <span class="n">pd</span> <span class="o">=</span> <span class="n">_check_pandas_installed</span><span class="p">()</span>
        <span class="n">mindex</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">ch_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Treat SourceEstimates special because they don&#39;t have the same info</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">T</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;subject&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># surface source estimates</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;LH&#39;</span> <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;RH&#39;</span><span class="p">,</span> <span class="n">vert</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">vertno</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">vertno</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># volume source estimates</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;VOL </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseEpochs</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">)):</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="s1">&#39;epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()[:,</span> <span class="n">picks</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
                <span class="n">n_epochs</span><span class="p">,</span> <span class="n">n_picks</span><span class="p">,</span> <span class="n">n_times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (time*epochs) x signals</span>

                <span class="c1"># Multi-index creation</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">n_epochs</span><span class="p">)</span>
                <span class="n">id_swapped</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_swapped</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span>
                <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;condition&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">n_times</span><span class="p">)))</span>
                <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;epoch&#39;</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">),</span> <span class="n">n_times</span><span class="p">)))</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseRaw</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">)):</span>
                <span class="n">default_index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>
                <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>

            <span class="n">ch_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
            <span class="n">ch_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">][</span><span class="n">pp</span><span class="p">]</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">],</span>
                    <span class="n">ch_types</span><span class="p">))</span>

            <span class="n">ch_types_used</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">scalings</span> <span class="o">=</span> <span class="n">_handle_default</span><span class="p">(</span><span class="s1">&#39;scalings&#39;</span><span class="p">,</span> <span class="n">scalings</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">scalings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">ch_types</span><span class="p">:</span>
                    <span class="n">ch_types_used</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">ch_types_used</span><span class="p">:</span>
                <span class="n">scaling</span> <span class="o">=</span> <span class="n">scalings</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">))</span> <span class="k">if</span> <span class="n">ch_types</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">tt</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaling</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In case some other object gets this mixin w/o an explicit check</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Object must be one of Raw, Epochs, Evoked,  or &#39;</span> <span class="o">+</span>
                            <span class="s1">&#39;SourceEstimate. This is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="c1"># Make sure that the time index is scaled correctly</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">times</span> <span class="o">*</span> <span class="n">scaling_time</span><span class="p">)</span>
        <span class="n">mindex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_check_pandas_index_arguments</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">default_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mdx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mindex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mdx</span> <span class="ow">in</span> <span class="n">mindex</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">col_names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mindex</span><span class="p">):</span>
            <span class="n">df</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">index</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">long_format</span><span class="p">:</span>
                <span class="n">_set_pandas_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">default_index</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
                <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;source&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;channel&#39;</span>

        <span class="k">if</span> <span class="n">long_format</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">sig_idx</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">columns</span><span class="p">[</span><span class="n">sig_idx</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;observation&#39;</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;ch_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">ch_map</span><span class="p">)</span>

            <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">to_factor</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">cc</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">cc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;observation&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]]</span>
            <span class="n">_set_pandas_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">to_factor</span><span class="p">,</span> <span class="s1">&#39;category&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span>


<span class="k">class</span> <span class="nc">TimeMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to add sfreq and time_as_index capabilities to certain classes.&quot;&quot;&quot;</span>

    <span class="c1"># Overridden method signature does not match call...</span>
    <span class="k">def</span> <span class="nf">time_as_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">use_rounding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># lgtm</span>
        <span class="sd">&quot;&quot;&quot;Convert time to indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : list-like | float | int</span>
<span class="sd">            List of numbers or a number representing points in time.</span>
<span class="sd">        use_rounding : boolean</span>
<span class="sd">            If True, use rounding (instead of truncation) when converting</span>
<span class="sd">            times to indices. This can help avoid non-unique indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : ndarray</span>
<span class="sd">            Indices corresponding to the times supplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..source_estimate</span> <span class="k">import</span> <span class="n">_BaseSourceEstimate</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_BaseSourceEstimate</span><span class="p">):</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tstep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sfreq</span>
        <span class="k">if</span> <span class="n">use_rounding</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<span class="nd">@fill_doc</span>
<span class="k">class</span> <span class="nc">BaseRaw</span><span class="p">(</span><span class="n">ProjMixin</span><span class="p">,</span> <span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span> <span class="n">SetChannelsMixin</span><span class="p">,</span>
              <span class="n">InterpolationMixin</span><span class="p">,</span> <span class="n">ToDataFrameMixin</span><span class="p">,</span> <span class="n">TimeMixin</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">,</span>
              <span class="n">HilbertMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Raw data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        A dict passed from the subclass.</span>
<span class="sd">    preload : bool | str | ndarray</span>
<span class="sd">        Preload data into memory for data manipulation and faster indexing.</span>
<span class="sd">        If True, the data will be preloaded into memory (fast, requires</span>
<span class="sd">        large amount of memory). If preload is a string, preload is the</span>
<span class="sd">        file name of a memory-mapped file which is used to store the data</span>
<span class="sd">        on the hard drive (slower, requires less memory). If preload is an</span>
<span class="sd">        ndarray, the data are taken from that array. If False, data are not</span>
<span class="sd">        read until save.</span>
<span class="sd">    first_samps : iterable</span>
<span class="sd">        Iterable of the first sample number from each raw file. For unsplit raw</span>
<span class="sd">        files this should be a length-one list or tuple.</span>
<span class="sd">    last_samps : iterable | None</span>
<span class="sd">        Iterable of the last sample number from each raw file. For unsplit raw</span>
<span class="sd">        files this should be a length-one list or tuple. If None, then preload</span>
<span class="sd">        must be an ndarray.</span>
<span class="sd">    filenames : tuple</span>
<span class="sd">        Tuple of length one (for unsplit raw files) or length &gt; 1 (for split</span>
<span class="sd">        raw files).</span>
<span class="sd">    raw_extras : list</span>
<span class="sd">        Whatever data is necessary for on-demand reads for the given</span>
<span class="sd">        reader format.</span>
<span class="sd">    orig_format : str</span>
<span class="sd">        The data format of the original raw file (e.g., ``&#39;double&#39;``).</span>
<span class="sd">    dtype : dtype | None</span>
<span class="sd">        The dtype of the raw data. If preload is an ndarray, its dtype must</span>
<span class="sd">        match what is passed here.</span>
<span class="sd">    buffer_size_sec : float</span>
<span class="sd">        The buffer size in seconds that should be written by default using</span>
<span class="sd">        :meth:`mne.io.Raw.save`.</span>
<span class="sd">    orig_units : dict | None</span>
<span class="sd">        Dictionary mapping channel names to their units as specified in</span>
<span class="sd">        the header file. Example: {&#39;FC1&#39;: &#39;nV&#39;}</span>

<span class="sd">        .. versionadded:: 0.17</span>
<span class="sd">    %(verbose)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is public to allow for stable type-checking in user</span>
<span class="sd">    code (i.e., ``isinstance(my_raw_object, BaseRaw)``) but should not be used</span>
<span class="sd">    as a constructor for `Raw` objects (use instead one of the subclass</span>
<span class="sd">    constructors, or one of the ``mne.io.read_raw_*`` functions).</span>

<span class="sd">    Subclasses must provide the following methods:</span>

<span class="sd">        * _read_segment_file(self, data, idx, fi, start, stop, cals, mult)</span>
<span class="sd">          (only needed for types that support on-demand disk reads)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mne.io.Raw : Documentation of attribute and methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">first_samps</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">last_samps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filenames</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">raw_extras</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span>
                 <span class="n">orig_format</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                 <span class="n">buffer_size_sec</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">orig_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="c1"># wait until the end to preload data, but triage here</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># some functions (e.g., filtering) only work w/64-bit data</span>
            <span class="k">if</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;datatype must be float64 or complex128, &#39;</span>
                                   <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">preload</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;preload and dtype must match&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">preload</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_samps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">last_samps</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">last_samps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;last_samps must be given unless preload is &#39;</span>
                                 <span class="s1">&#39;an ndarray&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">preload</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad preload: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">preload</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">load_from_disk</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">last_samps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">first_samps</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>  <span class="c1"># make sure subclass did a good job</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size_sec</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">buffer_size_sec</span><span class="p">)</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]):</span>
            <span class="n">cals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad cals for channels </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">{</span><span class="n">ii</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">bad</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="n">cals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">raw_extras</span><span class="p">)</span>
        <span class="c1"># deal with compensation (only relevant for CTF data, either CTF</span>
        <span class="c1"># reader or MNE-C converted CTF-&gt;FIF files)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compensation_grade</span>  <span class="c1"># read property</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Current compensation grade : </span><span class="si">%d</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">=</span> <span class="n">orig_format</span>
        <span class="c1"># Sanity check and set original units, if provided by the reader:</span>
        <span class="k">if</span> <span class="n">orig_units</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_units</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;orig_units must be of type dict, but got &#39;</span>
                                 <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">orig_units</span><span class="p">)))</span>

            <span class="c1"># original units need to be truncated to 15 chars, which is what</span>
            <span class="c1"># the MNE IO procedure also does with the other channels</span>
            <span class="n">orig_units_trunc</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="p">[:</span><span class="mi">15</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">orig_units</span><span class="p">]</span>

            <span class="c1"># STI 014 channel is native only to fif ... for all other formats</span>
            <span class="c1"># this was artificially added by the IO procedure, so remove it</span>
            <span class="n">ch_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;STI 014&#39;</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.fif&#39;</span><span class="p">)):</span>
                <span class="n">ch_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;STI 014&#39;</span><span class="p">)</span>

            <span class="c1"># Each channel in the data must have a corresponding channel in</span>
            <span class="c1"># the original units.</span>
            <span class="n">ch_correspond</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="ow">in</span> <span class="n">orig_units_trunc</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ch_correspond</span><span class="p">):</span>
                <span class="n">ch_without_orig_unit</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">ch_correspond</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">False</span><span class="p">)]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel </span><span class="si">{}</span><span class="s1"> has no associated original &#39;</span>
                                 <span class="s1">&#39;unit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ch_without_orig_unit</span><span class="p">))</span>

            <span class="c1"># Final check of orig_units, editing a unit if it is not a valid</span>
            <span class="c1"># unit</span>
            <span class="n">orig_units</span> <span class="o">=</span> <span class="n">_check_orig_units</span><span class="p">(</span><span class="n">orig_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_units</span> <span class="o">=</span> <span class="n">orig_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_annotations</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># If we have True or a string, actually do the preloading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">load_from_disk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preload_data</span><span class="p">(</span><span class="n">preload</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">_get_argvalues</span><span class="p">()</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_gradient_compensation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grade</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply CTF gradient compensation.</span>

<span class="sd">        .. warning:: The compensation matrices are stored with single</span>
<span class="sd">                     precision, so repeatedly switching between different</span>
<span class="sd">                     of compensation (e.g., 0-&gt;1-&gt;3-&gt;2) can increase</span>
<span class="sd">                     numerical noise, especially if data are saved to</span>
<span class="sd">                     disk in between changing grades. It is thus best to</span>
<span class="sd">                     only use a single gradient compensation level in</span>
<span class="sd">                     final analyses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grade : int</span>
<span class="sd">            CTF gradient compensation level.</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The modified Raw instance. Works in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grade</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">grade</span><span class="p">)</span>
        <span class="n">current_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compensation_grade</span>
        <span class="k">if</span> <span class="n">current_comp</span> <span class="o">!=</span> <span class="n">grade</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change compensation on data where &#39;</span>
                                   <span class="s1">&#39;projectors have been applied&#39;</span><span class="p">)</span>
            <span class="c1"># Figure out what operator to use (varies depending on preload)</span>
            <span class="n">from_comp</span> <span class="o">=</span> <span class="n">current_comp</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_comp_grade</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">make_compensator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">from_comp</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compensator constructed to change </span><span class="si">%d</span><span class="s1"> -&gt; </span><span class="si">%d</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">current_comp</span><span class="p">,</span> <span class="n">grade</span><span class="p">))</span>
            <span class="n">set_current_comp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">grade</span><span class="p">)</span>
            <span class="c1"># We might need to apply it to our data now</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Applying compensator to loaded data&#39;</span><span class="p">)</span>
                <span class="n">lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">),</span> <span class="mi">10000</span><span class="p">),</span>
                                       <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)]])</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="n">comp</span>  <span class="c1"># store it for later use</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Datatype for loading data (property so subclasses can override).&quot;&quot;&quot;</span>
        <span class="c1"># most classes only store real data, they won&#39;t need anything special</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_</span>

    <span class="k">def</span> <span class="nf">_read_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">projector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a chunk of raw data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, (optional)</span>
<span class="sd">            first sample to include (first is 0). If omitted, defaults to the</span>
<span class="sd">            first sample in data.</span>
<span class="sd">        stop : int, (optional)</span>
<span class="sd">            First sample to not include.</span>
<span class="sd">            If omitted, data is included to the end.</span>
<span class="sd">        sel : array, optional</span>
<span class="sd">            Indices of channels to select.</span>
<span class="sd">        data_buffer : array or str, optional</span>
<span class="sd">            numpy array to fill with data read, must have the correct shape.</span>
<span class="sd">            If str, a np.memmap with the correct data type will be used</span>
<span class="sd">            to store the data.</span>
<span class="sd">        projector : array</span>
<span class="sd">            SSP operator to apply to the data.</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array, [channels x samples]</span>
<span class="sd">           the data matrix (channels x samples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Initial checks</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">min</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">stop</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No data in this range&#39;</span><span class="p">)</span>

        <span class="c1">#  Initialize the data and calibration vector</span>
        <span class="n">n_sel_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">n_sel_channels</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
        <span class="c1"># convert sel to a slice if possible for efficiency</span>
        <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sel</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_sel_channels</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data_buffer</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data_buffer has incorrect shape: </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">data_buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data_buffer</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># use a memmap</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># deal with having multiple files accessed by the raw object</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)))</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cumul_lens</span><span class="p">)</span>
        <span class="n">files_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                     <span class="n">cumul_lens</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># set up cals and mult (cals, compensation, and projector)</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">*</span> <span class="n">cals</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projector</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mult</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">cals</span>
        <span class="k">elif</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="n">projector</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">cals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="n">cals</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># read from necessary files</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">files_used</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">start_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>
            <span class="c1"># first iteration (only) could start in the middle somewhere</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_file</span> <span class="o">+=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>
            <span class="n">stop_file</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">stop</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">start_file</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="ow">or</span> <span class="n">stop_file</span> <span class="o">&lt;</span> <span class="n">start_file</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad array indexing, could be a bug&#39;</span><span class="p">)</span>
            <span class="n">n_read</span> <span class="o">=</span> <span class="n">stop_file</span> <span class="o">-</span> <span class="n">start_file</span>
            <span class="n">this_sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">n_read</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment_file</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">this_sl</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
                                    <span class="nb">int</span><span class="p">(</span><span class="n">start_file</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">stop_file</span><span class="p">),</span>
                                    <span class="n">cals</span><span class="p">,</span> <span class="n">mult</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">n_read</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_read_segment_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">mult</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a segment of data from a file.</span>

<span class="sd">        Only needs to be implemented for readers that support</span>
<span class="sd">        ``preload=False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ndarray, shape (len(idx), stop - start + 1)</span>
<span class="sd">            The data array. Should be modified inplace.</span>
<span class="sd">        idx : ndarray | slice</span>
<span class="sd">            The requested channel indices.</span>
<span class="sd">        fi : int</span>
<span class="sd">            The file index that must be read from.</span>
<span class="sd">        start : int</span>
<span class="sd">            The start sample in the given file.</span>
<span class="sd">        stop : int</span>
<span class="sd">            The stop sample in the given file (inclusive).</span>
<span class="sd">        cals : ndarray, shape (len(idx), 1)</span>
<span class="sd">            Channel calibrations (already sub-indexed).</span>
<span class="sd">        mult : ndarray, shape (len(idx), len(info[&#39;chs&#39;]) | None</span>
<span class="sd">            The compensation + projection + cals matrix, if applicable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_check_bad_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span>
                           <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if data segment is bad.</span>

<span class="sd">        If the slice is good, returns the data in desired range.</span>
<span class="sd">        If rejected based on annotation, returns description of the</span>
<span class="sd">        bad segment as a string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            First sample of the slice.</span>
<span class="sd">        stop : int</span>
<span class="sd">            End of the slice.</span>
<span class="sd">        picks : array of int</span>
<span class="sd">            Channel picks.</span>
<span class="sd">        reject_by_annotation : bool</span>
<span class="sd">            Whether to perform rejection based on annotations.</span>
<span class="sd">            False by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array | str</span>
<span class="sd">            Data in the desired range (good segment) or description of the bad</span>
<span class="sd">            segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">reject_by_annotation</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">annot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
            <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="n">_sync_onset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annot</span><span class="o">.</span><span class="n">onset</span><span class="p">)</span>
            <span class="n">overlaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onset</span> <span class="o">&lt;</span> <span class="n">stop</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)</span>
            <span class="n">overlaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onset</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]</span> <span class="o">+</span> <span class="n">annot</span><span class="o">.</span><span class="n">duration</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]</span> <span class="o">&gt;</span>
                                <span class="n">start</span> <span class="o">/</span> <span class="n">sfreq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">descr</span> <span class="ow">in</span> <span class="n">annot</span><span class="o">.</span><span class="n">description</span><span class="p">[</span><span class="n">overlaps</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">descr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bad&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">descr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load raw data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw object with data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function will load raw data if it was not already preloaded.</span>
<span class="sd">        If data were already preloaded, it will do nothing.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_preload_data</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_preload_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preload</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Actually preload the data.&quot;&quot;&quot;</span>
        <span class="n">data_buffer</span> <span class="o">=</span> <span class="n">preload</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%d</span><span class="s1"> ... </span><span class="si">%d</span><span class="s1">  =  </span><span class="si">%9.3f</span><span class="s1"> ... </span><span class="si">%9.3f</span><span class="s1"> secs...&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">data_buffer</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no longer needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update times.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="c1"># make it immutable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_first_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_samp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The first data sample.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_samp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The last data sample.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_last_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

    <span class="c1"># &quot;Overridden method signature does not match call...&quot; in LGTM</span>
    <span class="k">def</span> <span class="nf">time_as_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">use_rounding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># lgtm</span>
        <span class="sd">&quot;&quot;&quot;Convert time to indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : list-like | float | int</span>
<span class="sd">            List of numbers or a number representing points in time.</span>
<span class="sd">        use_rounding : boolean</span>
<span class="sd">            If True, use rounding (instead of truncation) when converting</span>
<span class="sd">            times to indices. This can help avoid non-unique indices.</span>
<span class="sd">        origin: time-like | float | int | None</span>
<span class="sd">            Time reference for times. If None, ``times`` are assumed to be</span>
<span class="sd">            relative to ``first_samp``.</span>

<span class="sd">            .. versionadded:: 0.17.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index : ndarray</span>
<span class="sd">            Indices relative to ``first_samp`` corresponding to the times</span>
<span class="sd">            supplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">first_samp_in_abs_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">_handle_meas_date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">])</span> <span class="o">+</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_first_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">first_samp_in_abs_time</span>

        <span class="n">absolute_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span> <span class="n">_handle_meas_date</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="n">absolute_time</span> <span class="o">-</span> <span class="n">first_samp_in_abs_time</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseRaw</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">use_rounding</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_raw_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D401</span>
        <span class="sd">&quot;&quot;&quot;:class:`~mne.Annotations` for marking segments of data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The filenames used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">,</span> <span class="n">emit_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for annotations.</span>

<span class="sd">        This setter checks if they are inside the data range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annotations : instance of mne.Annotations | None</span>
<span class="sd">            Annotations to set. If None, the annotations is defined</span>
<span class="sd">            but empty.</span>
<span class="sd">        emit_warning : bool</span>
<span class="sd">            Whether to emit warnings when limiting or omitting annotations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of Raw</span>
<span class="sd">            The raw object with annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meas_date</span> <span class="o">=</span> <span class="n">_handle_meas_date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">orig_time</span> <span class="o">=</span> <span class="n">meas_date</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orig_time</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">orig_time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ensure_annotation_object</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> \
               <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Ambiguous operation. Setting an Annotation&#39;</span>
                                   <span class="s1">&#39; object with known ``orig_time`` to a raw&#39;</span>
                                   <span class="s1">&#39; object which has ``meas_date`` set to&#39;</span>
                                   <span class="s1">&#39; None is ambiguous. Please, either set a&#39;</span>
                                   <span class="s1">&#39; meaningful ``meas_date`` to the raw&#39;</span>
                                   <span class="s1">&#39; object; or set ``orig_time`` to None in&#39;</span>
                                   <span class="s1">&#39; which case the annotation onsets would be&#39;</span>
                                   <span class="s1">&#39; taken in reference to the first sample of&#39;</span>
                                   <span class="s1">&#39; the raw object.&#39;</span><span class="p">)</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
            <span class="n">time_of_first_sample</span> <span class="o">=</span> <span class="n">meas_date</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">*</span> <span class="n">delta</span>
            <span class="n">new_annotations</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Assume annotations to be relative to the data</span>
                <span class="n">new_annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">=</span> <span class="n">time_of_first_sample</span>

            <span class="n">tmin</span> <span class="o">=</span> <span class="n">time_of_first_sample</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">tmin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span>
            <span class="n">new_annotations</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span>
                                 <span class="n">emit_warning</span><span class="o">=</span><span class="n">emit_warning</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">!=</span> <span class="n">meas_date</span><span class="p">:</span>
                <span class="c1"># XXX, TODO: this should be a function, method or something.</span>
                <span class="c1"># maybe orig_time should have a setter</span>
                <span class="c1"># new_annotations.orig_time = xxxxx # resets onset based on x</span>
                <span class="c1"># new_annotations._update_orig(xxxx)</span>
                <span class="n">orig_time</span> <span class="o">=</span> <span class="n">new_annotations</span><span class="o">.</span><span class="n">orig_time</span>
                <span class="n">new_annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">=</span> <span class="n">meas_date</span>
                <span class="n">new_annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">-=</span> <span class="p">(</span><span class="n">meas_date</span> <span class="o">-</span> <span class="n">orig_time</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">new_annotations</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D105</span>
        <span class="c1"># remove file for memmap</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># First, close the file out; happens automatically on del</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="c1"># Now file can be removed</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># ignore file that no longer exists</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Entering with block.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_val</span><span class="p">,</span> <span class="n">trace</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exit with block.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_val</span><span class="p">,</span> <span class="n">trace</span>

    <span class="k">def</span> <span class="nf">_parse_get_set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the __getitem__ / __setitem__ tuples.&quot;&quot;&quot;</span>
        <span class="c1"># make sure item is a tuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># only channel selection passed</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># should be channels and time instants</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to access raw data (need both channels &quot;</span>
                               <span class="s2">&quot;and time)&quot;</span><span class="p">)</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">time_slice</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">time_slice</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                                 <span class="n">time_slice</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item1</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Let&#39;s do automated type conversion to integer here</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">item1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must pass int or slice to __getitem__&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;step needs to be 1 : </span><span class="si">%d</span><span class="s1"> given&#39;</span> <span class="o">%</span> <span class="n">step</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sel</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty channel list&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get raw data and times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : tuple or array-like</span>
<span class="sd">            See below for use cases.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray, shape (n_channels, n_times)</span>
<span class="sd">            The raw data.</span>
<span class="sd">        times : ndarray, shape (n_times,)</span>
<span class="sd">            The times associated with the data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generally raw data is accessed as::</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[picks, time_slice]  # doctest: +SKIP</span>

<span class="sd">        To get all data, you can thus do either of::</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[:]  # doctest: +SKIP</span>

<span class="sd">        Which will be equivalent to:</span>

<span class="sd">            &gt;&gt;&gt; data, times = raw[:, :]  # doctest: +SKIP</span>

<span class="sd">        To get only the good MEG data from 10-20 seconds, you could do::</span>

<span class="sd">            &gt;&gt;&gt; picks = mne.pick_types(raw.info, meg=True, exclude=&#39;bads&#39;)  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; t_idx = raw.time_as_index([10., 20.])  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; data, times = raw[picks, t_idx[0]:t_idx[1]]  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_set_params</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="n">sel</span><span class="p">,</span>
                                      <span class="n">projector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set raw data content.&quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Modifying data of Raw&#39;</span><span class="p">)</span>
        <span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_set_params</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># set the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_times</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data in the given range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(picks_all)s</span>
<span class="sd">        start : int</span>
<span class="sd">            The first sample to include. Defaults to 0.</span>
<span class="sd">        stop : int | None</span>
<span class="sd">            End sample (first not to include). If None (default), the end of</span>
<span class="sd">            the data is  used.</span>
<span class="sd">        reject_by_annotation : None | &#39;omit&#39; | &#39;NaN&#39;</span>
<span class="sd">            Whether to reject by annotation. If None (default), no rejection is</span>
<span class="sd">            done. If &#39;omit&#39;, segments annotated with description starting with</span>
<span class="sd">            &#39;bad&#39; are omitted. If &#39;NaN&#39;, the bad samples are filled with NaNs.</span>
<span class="sd">        return_times : bool</span>
<span class="sd">            Whether to return times as well. Defaults to False.</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray, shape (n_channels, n_times)</span>
<span class="sd">            Copy of the data in the given range.</span>
<span class="sd">        times : ndarray, shape (n_times,)</span>
<span class="sd">            Times associated with the data samples. Only returned if</span>
<span class="sd">            return_times=True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.14.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">())</span>
        <span class="c1"># convert to ints</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])[</span><span class="n">picks</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">reject_by_annotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_times</span> <span class="k">else</span> <span class="n">data</span>
        <span class="n">_check_option</span><span class="p">(</span><span class="s1">&#39;reject_by_annotation&#39;</span><span class="p">,</span> <span class="n">reject_by_annotation</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                      <span class="p">[</span><span class="s1">&#39;omit&#39;</span><span class="p">,</span> <span class="s1">&#39;nan&#39;</span><span class="p">])</span>
        <span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">_annotations_starts_stops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;BAD&#39;</span><span class="p">])</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">onsets</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ends</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">return_times</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>  <span class="c1"># total number of samples</span>
        <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">onset</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">used</span><span class="p">[</span><span class="n">onset</span> <span class="o">-</span> <span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="kc">False</span><span class="p">],</span> <span class="n">used</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]])</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">used</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">start</span>
        <span class="n">stops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">used</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">start</span>
        <span class="n">n_kept</span> <span class="o">=</span> <span class="p">(</span><span class="n">stops</span> <span class="o">-</span> <span class="n">starts</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># kept samples</span>
        <span class="n">n_rejected</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">-</span> <span class="n">n_kept</span>  <span class="c1"># rejected samples</span>
        <span class="k">if</span> <span class="n">n_rejected</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reject_by_annotation</span> <span class="o">==</span> <span class="s1">&#39;omit&#39;</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Omitting </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:.2%}</span><span class="s2">) samples, retaining </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot; (</span><span class="si">{:.2%}</span><span class="s2">) samples.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_rejected</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span>
                                       <span class="n">n_rejected</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">,</span>
                                       <span class="n">n_kept</span><span class="p">,</span> <span class="n">n_kept</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">),</span> <span class="n">n_kept</span><span class="p">))</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">):</span>  <span class="c1"># get the data</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">end</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{:.2%}</span><span class="s2">) samples to NaN, retaining </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot; (</span><span class="si">{:.2%}</span><span class="s2">) samples.&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_rejected</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span>
                                       <span class="n">n_rejected</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">,</span>
                                       <span class="n">n_kept</span><span class="p">,</span> <span class="n">n_kept</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">))</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="o">~</span><span class="n">used</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_times</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">channel_wise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a function to a subset of channels.</span>

<span class="sd">        The function &quot;fun&quot; is applied to the channels defined in &quot;picks&quot;. The</span>
<span class="sd">        data of the Raw object is modified inplace. If the function returns</span>
<span class="sd">        a different data type (e.g. numpy.complex) it must be specified using</span>
<span class="sd">        the dtype parameter, which causes the data type used for representing</span>
<span class="sd">        the raw data to change.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        .. note:: If the data type changes (dtype != None), more memory is</span>
<span class="sd">                  required since the original and the converted data needs</span>
<span class="sd">                  to be stored in memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fun : callable</span>
<span class="sd">            A function to be applied to the channels. The first argument of</span>
<span class="sd">            fun has to be a timeseries (numpy.ndarray). The function must</span>
<span class="sd">            operate on an array of shape ``(n_times,)`` if</span>
<span class="sd">            ``channel_wise=True`` and ``(len(picks), n_times)`` otherwise.</span>
<span class="sd">            The function must return an ndarray shaped like its input.</span>
<span class="sd">        %(picks_all_data_noref)s</span>
<span class="sd">        dtype : numpy.dtype (default: None)</span>
<span class="sd">            Data type to use for raw data after applying the function. If None</span>
<span class="sd">            the data type is not modified.</span>
<span class="sd">        n_jobs: int (default: 1)</span>
<span class="sd">            Number of jobs to run in parallel. Ignored if `channel_wise` is</span>
<span class="sd">            False.</span>
<span class="sd">        channel_wise: bool (default: True)</span>
<span class="sd">            Whether to apply the function to each channel individually. If</span>
<span class="sd">            False, the function will be applied to all channels at once.</span>

<span class="sd">            .. versionadded:: 0.18</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments to pass to fun (first pos. argument</span>
<span class="sd">            of fun is the timeseries of a channel).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments to pass to fun. Note that if &quot;verbose&quot; is passed</span>
<span class="sd">            as a member of ``kwargs``, it will be consumed and will override</span>
<span class="sd">            the default mne-python verbose level (see :func:`mne.verbose` and</span>
<span class="sd">            :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of Raw</span>
<span class="sd">            The raw object with transformed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.apply_function&#39;</span><span class="p">)</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">(),</span> <span class="n">with_ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fun needs to be a function&#39;</span><span class="p">)</span>

        <span class="n">data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channel_wise</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># modify data inplace to save memory</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_check_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">data_in</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span>
                                                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use parallel function</span>
                <span class="n">parallel</span><span class="p">,</span> <span class="n">p_fun</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parallel_func</span><span class="p">(</span><span class="n">_check_fun</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">)</span>
                <span class="n">data_picks_new</span> <span class="o">=</span> <span class="n">parallel</span><span class="p">(</span>
                    <span class="n">p_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">data_in</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">picks</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data_picks_new</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_check_fun</span><span class="p">(</span>
                <span class="n">fun</span><span class="p">,</span> <span class="n">data_in</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="p">:],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
               <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span>
               <span class="n">fir_window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="s1">&#39;firwin&#39;</span><span class="p">,</span>
               <span class="n">skip_by_annotation</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="s1">&#39;bad_acq_skip&#39;</span><span class="p">),</span>
               <span class="n">pad</span><span class="o">=</span><span class="s1">&#39;reflect_limited&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter a subset of channels.</span>

<span class="sd">        Applies a zero-phase low-pass, high-pass, band-pass, or band-stop</span>
<span class="sd">        filter to the channels selected by ``picks``. By default the data</span>
<span class="sd">        of the Raw object is modified inplace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(l_freq)s</span>
<span class="sd">        %(h_freq)s</span>
<span class="sd">        %(picks_all_data)s</span>
<span class="sd">        %(filter_length)s</span>
<span class="sd">        %(l_trans_bandwidth)s</span>
<span class="sd">        %(h_trans_bandwidth)s</span>
<span class="sd">        %(n_jobs-fir)s</span>
<span class="sd">        %(method-fir)s</span>
<span class="sd">        %(iir_params)s</span>
<span class="sd">        %(phase)s</span>
<span class="sd">        %(fir_window)s</span>
<span class="sd">        %(fir_design)s</span>
<span class="sd">        skip_by_annotation : str | list of str</span>
<span class="sd">            If a string (or list of str), any annotation segment that begins</span>
<span class="sd">            with the given string will not be included in filtering, and</span>
<span class="sd">            segments on either side of the given excluded annotated segment</span>
<span class="sd">            will be filtered separately (i.e., as independent signals).</span>
<span class="sd">            The default (``(&#39;edge&#39;, &#39;bad_acq_skip&#39;)`` will separately filter</span>
<span class="sd">            any segments that were concatenated by :func:`mne.concatenate_raws`</span>
<span class="sd">            or :meth:`mne.io.Raw.append`, or separated during acquisition.</span>
<span class="sd">            To disable, provide an empty list.</span>

<span class="sd">            .. versionadded:: 0.16.</span>
<span class="sd">        %(pad-fir)s</span>
<span class="sd">            The default is ``&#39;reflect-limited&#39;``.</span>

<span class="sd">            .. versionadded:: 0.15</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw instance with filtered data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.Epochs.savgol_filter</span>
<span class="sd">        mne.io.Raw.notch_filter</span>
<span class="sd">        mne.io.Raw.resample</span>
<span class="sd">        mne.filter.create_filter</span>
<span class="sd">        mne.filter.filter_data</span>
<span class="sd">        mne.filter.construct_iir_filter</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        ``l_freq`` and ``h_freq`` are the frequencies below which and above</span>
<span class="sd">        which, respectively, to filter out of the data. Thus the uses are:</span>

<span class="sd">            * ``l_freq &lt; h_freq``: band-pass filter</span>
<span class="sd">            * ``l_freq &gt; h_freq``: band-stop filter</span>
<span class="sd">            * ``l_freq is not None and h_freq is None``: high-pass filter</span>
<span class="sd">            * ``l_freq is None and h_freq is not None``: low-pass filter</span>

<span class="sd">        ``self.info[&#39;lowpass&#39;]`` and ``self.info[&#39;highpass&#39;]`` are only</span>
<span class="sd">        updated with picks=None.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        For more information, see the tutorials</span>
<span class="sd">        :ref:`disc-filtering` and :ref:`tut-filter-resample` and</span>
<span class="sd">        :func:`mne.filter.create_filter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.filter&#39;</span><span class="p">)</span>
        <span class="n">update_info</span><span class="p">,</span> <span class="n">picks</span> <span class="o">=</span> <span class="n">_filt_check_picks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span>
                                               <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">)</span>
        <span class="c1"># Deal with annotations</span>
        <span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="n">_annotations_starts_stops</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">skip_by_annotation</span><span class="p">,</span> <span class="s1">&#39;skip_by_annotation&#39;</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Filtering raw data in </span><span class="si">%d</span><span class="s1"> contiguous segment</span><span class="si">%s</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">onsets</span><span class="p">),</span> <span class="n">_pl</span><span class="p">(</span><span class="n">onsets</span><span class="p">)))</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ends</span> <span class="o">-</span> <span class="n">onsets</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">ends</span><span class="p">)):</span>
            <span class="c1"># Only output filter params once (for info level), and only warn</span>
            <span class="c1"># once about the length criterion (longest segment is too short)</span>
            <span class="n">use_verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="k">if</span> <span class="n">si</span> <span class="o">==</span> <span class="n">max_idx</span> <span class="k">else</span> <span class="s1">&#39;error&#39;</span>
            <span class="n">filter_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">,</span>
                <span class="n">picks</span><span class="p">,</span> <span class="n">filter_length</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">iir_params</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span>
                <span class="n">fir_window</span><span class="o">=</span><span class="n">fir_window</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="n">fir_design</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">use_verbose</span><span class="p">)</span>
        <span class="c1"># update info if filter is applied to all data channels,</span>
        <span class="c1"># and it&#39;s not a band-stop filter</span>
        <span class="n">_filt_update_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">update_info</span><span class="p">,</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">notch_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                     <span class="n">notch_widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trans_bandwidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mt_bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">p_value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="n">fir_window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span>
                     <span class="n">fir_design</span><span class="o">=</span><span class="s1">&#39;firwin&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="s1">&#39;reflect_limited&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Notch filter a subset of channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freqs : float | array of float | None</span>
<span class="sd">            Specific frequencies to filter out from data, e.g.,</span>
<span class="sd">            np.arange(60, 241, 60) in the US or np.arange(50, 251, 50) in</span>
<span class="sd">            Europe. None can only be used with the mode &#39;spectrum_fit&#39;,</span>
<span class="sd">            where an F test is used to find sinusoidal components.</span>
<span class="sd">        %(picks_all_data)s</span>
<span class="sd">        %(filter_length)s</span>
<span class="sd">        notch_widths : float | array of float | None</span>
<span class="sd">            Width of each stop band (centred at each freq in freqs) in Hz.</span>
<span class="sd">            If None, freqs / 200 is used.</span>
<span class="sd">        trans_bandwidth : float</span>
<span class="sd">            Width of the transition band in Hz.</span>
<span class="sd">            Only used for ``method=&#39;fir&#39;``.</span>
<span class="sd">        %(n_jobs-fir)s</span>
<span class="sd">        %(method-fir)s</span>
<span class="sd">        %(iir_params)s</span>
<span class="sd">        mt_bandwidth : float | None</span>
<span class="sd">            The bandwidth of the multitaper windowing function in Hz.</span>
<span class="sd">            Only used in &#39;spectrum_fit&#39; mode.</span>
<span class="sd">        p_value : float</span>
<span class="sd">            p-value to use in F-test thresholding to determine significant</span>
<span class="sd">            sinusoidal components to remove when method=&#39;spectrum_fit&#39; and</span>
<span class="sd">            freqs=None. Note that this will be Bonferroni corrected for the</span>
<span class="sd">            number of frequencies, so large p-values may be justified.</span>
<span class="sd">        %(phase)s</span>
<span class="sd">        %(fir_window)s</span>
<span class="sd">        %(fir_design)s</span>
<span class="sd">        %(pad-fir)s</span>
<span class="sd">            The default is ``&#39;reflect_limited&#39;``.</span>

<span class="sd">            .. versionadded:: 0.15</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The raw instance with filtered data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.filter.notch_filter</span>
<span class="sd">        mne.io.Raw.filter</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Applies a zero-phase notch filter to the channels selected by</span>
<span class="sd">        &quot;picks&quot;. By default the data of the Raw object is modified inplace.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. note:: If n_jobs &gt; 1, more memory is required as</span>
<span class="sd">                  ``len(picks) * n_times`` additional time points need to</span>
<span class="sd">                  be temporaily stored in memory.</span>

<span class="sd">        For details, see :func:`mne.filter.notch_filter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">(),</span> <span class="n">none</span><span class="o">=</span><span class="s1">&#39;data_or_ica&#39;</span><span class="p">)</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.notch_filter&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">notch_filter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">filter_length</span><span class="o">=</span><span class="n">filter_length</span><span class="p">,</span>
            <span class="n">notch_widths</span><span class="o">=</span><span class="n">notch_widths</span><span class="p">,</span> <span class="n">trans_bandwidth</span><span class="o">=</span><span class="n">trans_bandwidth</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">iir_params</span><span class="o">=</span><span class="n">iir_params</span><span class="p">,</span> <span class="n">mt_bandwidth</span><span class="o">=</span><span class="n">mt_bandwidth</span><span class="p">,</span>
            <span class="n">p_value</span><span class="o">=</span><span class="n">p_value</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span> <span class="n">fir_window</span><span class="o">=</span><span class="n">fir_window</span><span class="p">,</span> <span class="n">fir_design</span><span class="o">=</span><span class="n">fir_design</span><span class="p">,</span>
            <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="n">stim_picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="s1">&#39;reflect_limited&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample all channels.</span>

<span class="sd">        The Raw object has to have the data loaded e.g. with ``preload=True``</span>
<span class="sd">        or ``self.load_data()``.</span>

<span class="sd">        .. warning:: The intended purpose of this function is primarily to</span>
<span class="sd">                     speed up computations (e.g., projection calculation) when</span>
<span class="sd">                     precise timing of events is not required, as downsampling</span>
<span class="sd">                     raw data effectively jitters trigger timings. It is</span>
<span class="sd">                     generally recommended not to epoch downsampled data,</span>
<span class="sd">                     but instead epoch and then downsample, as epoching</span>
<span class="sd">                     downsampled data jitters triggers.</span>
<span class="sd">                     For more, see</span>
<span class="sd">                     `this illustrative gist</span>
<span class="sd">                     &lt;https://gist.github.com/larsoner/01642cb3789992fbca59&gt;`_.</span>

<span class="sd">                     If resampling the continuous data is desired, it is</span>
<span class="sd">                     recommended to construct events using the original data.</span>
<span class="sd">                     The event onsets can be jointly resampled with the raw</span>
<span class="sd">                     data using the &#39;events&#39; parameter (a resampled copy is</span>
<span class="sd">                     returned).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sfreq : float</span>
<span class="sd">            New sample rate to use.</span>
<span class="sd">        %(npad)s</span>
<span class="sd">        %(window-resample)s</span>
<span class="sd">        stim_picks : list of int | None</span>
<span class="sd">            Stim channels. These channels are simply subsampled or</span>
<span class="sd">            supersampled (without applying any filtering). This reduces</span>
<span class="sd">            resampling artifacts in stim channels, but may lead to missing</span>
<span class="sd">            triggers. If None, stim channels are automatically chosen using</span>
<span class="sd">            :func:`mne.pick_types`.</span>
<span class="sd">        %(n_jobs-cuda)s</span>
<span class="sd">        events : 2D array, shape (n_events, 3) | None</span>
<span class="sd">            An optional event matrix. When specified, the onsets of the events</span>
<span class="sd">            are resampled jointly with the data. NB: The input events are not</span>
<span class="sd">            modified, but a new array is returned with the raw instead.</span>
<span class="sd">        %(pad-fir)s</span>
<span class="sd">            The default is ``&#39;reflect_limited&#39;``.</span>

<span class="sd">            .. versionadded:: 0.15</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The resampled version of the raw object.</span>
<span class="sd">        events : array, shape (n_events, 3) | None</span>
<span class="sd">            If events are jointly resampled, these are returned with the raw.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.io.Raw.filter</span>
<span class="sd">        mne.Epochs.resample</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For some data, it may be more accurate to use ``npad=0`` to reduce</span>
<span class="sd">        artifacts. This is dataset dependent -- check your data!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;raw.resample&#39;</span><span class="p">)</span>

        <span class="c1"># When no event object is supplied, some basic detection of dropped</span>
        <span class="c1"># events is performed to generate a warning. Finding events can fail</span>
        <span class="c1"># for a variety of reasons, e.g. if no stim channel is present or it is</span>
        <span class="c1"># corrupted. This should not stop the resampling from working. The</span>
        <span class="c1"># warning should simply not be generated in this case.</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">original_events</span> <span class="o">=</span> <span class="n">find_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sfreq</span><span class="p">)</span>
        <span class="n">o_sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)))</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">ratio</span> <span class="o">=</span> <span class="n">sfreq</span> <span class="o">/</span> <span class="n">o_sfreq</span>

        <span class="c1"># set up stim channel processing</span>
        <span class="k">if</span> <span class="n">stim_picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stim_picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">stim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">stim_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">stim_picks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">)):</span>
            <span class="n">data_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">offsets</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span><span class="n">data_chunk</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">o_sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span>
                                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">))</span>
            <span class="n">new_ntimes</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># In empirical testing, it was faster to resample all channels</span>
            <span class="c1"># (above) and then replace the stim channels than it was to only</span>
            <span class="c1"># resample the proper subset of channels and then use np.insert()</span>
            <span class="c1"># to restore the stims.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stim_picks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stim_resampled</span> <span class="o">=</span> <span class="n">_resample_stim_channels</span><span class="p">(</span>
                    <span class="n">data_chunk</span><span class="p">[</span><span class="n">stim_picks</span><span class="p">],</span> <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">data_chunk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">ri</span><span class="p">][</span><span class="n">stim_picks</span><span class="p">]</span> <span class="o">=</span> <span class="n">stim_resampled</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_ntimes</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ntimes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfreq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lowpass&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;lowpass&#39;</span><span class="p">],</span> <span class="n">sfreq</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>

        <span class="c1"># See the comment above why we ignore all errors here.</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Did we loose events?</span>
                <span class="n">resampled_events</span> <span class="o">=</span> <span class="n">find_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resampled_events</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_events</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Resampling of the stim channels caused event &#39;</span>
                         <span class="s1">&#39;information to become unreliable. Consider finding &#39;</span>
                         <span class="s1">&#39;events on the original data and passing the event &#39;</span>
                         <span class="s1">&#39;matrix as a parameter.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># always make a copy of events</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">events</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop raw data file.</span>

<span class="sd">        Limit the data from the raw file to go between specific times. Note</span>
<span class="sd">        that the new tmin is assumed to be t=0 for all subsequently called</span>
<span class="sd">        functions (e.g., time_as_index, or Epochs). New first_samp and</span>
<span class="sd">        last_samp are set accordingly.</span>

<span class="sd">        Thus function operates in-place on the instance.</span>
<span class="sd">        Use :meth:`mne.io.Raw.copy` if operation on a copy is desired.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tmin : float</span>
<span class="sd">            New start time in seconds (must be &gt;= 0).</span>
<span class="sd">        tmax : float | None</span>
<span class="sd">            New end time in seconds of the data (cannot exceed data duration).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        raw : instance of Raw</span>
<span class="sd">            The cropped raw object, modified in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_time</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">max_time</span>

        <span class="k">if</span> <span class="n">tmin</span> <span class="o">&gt;</span> <span class="n">tmax</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmin (</span><span class="si">%s</span><span class="s1">) must be less than tmax (</span><span class="si">%s</span><span class="s1">)&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">tmin</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmin (</span><span class="si">%s</span><span class="s1">) must be &gt;= 0&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tmin</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">tmax</span> <span class="o">&gt;</span> <span class="n">max_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmax (</span><span class="si">%s</span><span class="s1">) must be less than or equal to the max &#39;</span>
                             <span class="s1">&#39;time (</span><span class="si">%0.4f</span><span class="s1"> sec)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tmax</span><span class="p">,</span> <span class="n">max_time</span><span class="p">))</span>

        <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_time_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span>
                                         <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_lengths</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)))</span>
        <span class="n">cumul_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cumul_lens</span><span class="p">)</span>
        <span class="n">keepers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">smax</span><span class="p">,</span> <span class="n">cumul_lens</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">keepers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keepers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="n">keepers</span><span class="p">])</span>
        <span class="c1"># Adjust first_samp of first used file!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">smin</span> <span class="o">-</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">keepers</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="n">keepers</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">cumul_lens</span><span class="p">[</span><span class="n">keepers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">smax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">keepers</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">keepers</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># slice and copy to avoid the reference to large array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">smin</span><span class="p">:</span><span class="n">smax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">-=</span> <span class="n">tmin</span>
        <span class="c1"># now call setter to filter out annotations outside of interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_annotations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffer_size_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">drop_small_buffer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>
             <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">split_size</span><span class="o">=</span><span class="s1">&#39;2GB&#39;</span><span class="p">,</span> <span class="n">split_naming</span><span class="o">=</span><span class="s1">&#39;neuromag&#39;</span><span class="p">,</span>
             <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save raw data to file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : string</span>
<span class="sd">            File name of the new dataset. This has to be a new filename</span>
<span class="sd">            unless data have been preloaded. Filenames should end with</span>
<span class="sd">            raw.fif, raw.fif.gz, raw_sss.fif, raw_sss.fif.gz, raw_tsss.fif</span>
<span class="sd">            or raw_tsss.fif.gz.</span>
<span class="sd">        %(picks_all)s</span>
<span class="sd">        tmin : float | None</span>
<span class="sd">            Time in seconds of first sample to save. If None first sample</span>
<span class="sd">            is used.</span>
<span class="sd">        tmax : float | None</span>
<span class="sd">            Time in seconds of last sample to save. If None last sample</span>
<span class="sd">            is used.</span>
<span class="sd">        buffer_size_sec : float | None</span>
<span class="sd">            Size of data chunks in seconds. If None (default), the buffer</span>
<span class="sd">            size of the original file is used.</span>
<span class="sd">        drop_small_buffer : bool</span>
<span class="sd">            Drop or not the last buffer. It is required by maxfilter (SSS)</span>
<span class="sd">            that only accepts raw files with buffers of the same size.</span>
<span class="sd">        proj : bool</span>
<span class="sd">            If True the data is saved with the projections applied (active).</span>

<span class="sd">            .. note:: If ``apply_proj()`` was used to apply the projections,</span>
<span class="sd">                      the projectons will be active even if ``proj`` is False.</span>

<span class="sd">        fmt : &#39;single&#39; | &#39;double&#39; | &#39;int&#39; | &#39;short&#39;</span>
<span class="sd">            Format to use to save raw data. Valid options are &#39;double&#39;,</span>
<span class="sd">            &#39;single&#39;, &#39;int&#39;, and &#39;short&#39; for 64- or 32-bit float, or 32- or</span>
<span class="sd">            16-bit integers, respectively. It is **strongly** recommended to</span>
<span class="sd">            use &#39;single&#39;, as this is backward-compatible, and is standard for</span>
<span class="sd">            maintaining precision. Note that using &#39;short&#39; or &#39;int&#39; may result</span>
<span class="sd">            in loss of precision, complex data cannot be saved as &#39;short&#39;,</span>
<span class="sd">            and neither complex data types nor real data stored as &#39;double&#39;</span>
<span class="sd">            can be loaded with the MNE command-line tools. See raw.orig_format</span>
<span class="sd">            to determine the format the original data were stored in.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            If True, the destination file (if it exists) will be overwritten.</span>
<span class="sd">            If False (default), an error will be raised if the file exists.</span>
<span class="sd">            To overwrite original file (the same one that was loaded),</span>
<span class="sd">            data must be preloaded upon reading.</span>
<span class="sd">        split_size : string | int</span>
<span class="sd">            Large raw files are automatically split into multiple pieces. This</span>
<span class="sd">            parameter specifies the maximum size of each piece. If the</span>
<span class="sd">            parameter is an integer, it specifies the size in Bytes. It is</span>
<span class="sd">            also possible to pass a human-readable string, e.g., 100MB.</span>

<span class="sd">            .. note:: Due to FIFF file limitations, the maximum split</span>
<span class="sd">                      size is 2GB.</span>

<span class="sd">        split_naming : {&#39;neuromag&#39; | &#39;bids&#39;}</span>
<span class="sd">            Add the filename partition with the appropriate naming schema.</span>

<span class="sd">            .. versionadded:: 0.17</span>

<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If Raw is a concatenation of several raw files, **be warned** that</span>
<span class="sd">        only the measurement information from the first raw file is stored.</span>
<span class="sd">        This likely means that certain operations with external tools may not</span>
<span class="sd">        work properly on a saved concatenated file (e.g., probably some</span>
<span class="sd">        or all forms of SSS). It is recommended not to concatenate and</span>
<span class="sd">        then save raw files for this reason.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;raw&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;raw.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_sss.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_tsss.fif&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;raw.fif.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_sss.fif.gz&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;raw_tsss.fif.gz&#39;</span><span class="p">))</span>

        <span class="n">split_size</span> <span class="o">=</span> <span class="n">_get_split_size</span><span class="p">(</span><span class="n">split_size</span><span class="p">)</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="ow">and</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You cannot save data to the same file.&#39;</span>
                             <span class="s1">&#39; Please use a different filename.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Saving raw file with complex data. Loading with &#39;</span>
                     <span class="s1">&#39;command-line MNE tools will not work.&#39;</span><span class="p">)</span>

        <span class="n">type_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">short</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_DAU_PACK16</span><span class="p">,</span>
                         <span class="nb">int</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_INT</span><span class="p">,</span>
                         <span class="n">single</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_FLOAT</span><span class="p">,</span>
                         <span class="n">double</span><span class="o">=</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFT_DOUBLE</span><span class="p">)</span>
        <span class="n">_check_option</span><span class="p">(</span><span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">reset_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">short</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">double</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">reset_range</span> <span class="o">=</span> <span class="n">reset_dict</span><span class="p">[</span><span class="n">fmt</span><span class="p">]</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">type_dict</span><span class="p">[</span><span class="n">fmt</span><span class="p">]</span>

        <span class="n">data_test</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;short&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">data_test</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Complex data must be saved as &quot;single&quot; or &#39;</span>
                             <span class="s1">&#39;&quot;double&quot;, not &quot;short&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># check for file existence</span>
        <span class="n">_check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">proj</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
            <span class="n">projector</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">setup_proj</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="n">activate_proj</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
            <span class="n">projector</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">#</span>
        <span class="c1">#   Set up the reading parameters</span>
        <span class="c1">#</span>

        <span class="c1">#   Convert to samples</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tmin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>

        <span class="c1"># &quot;stop&quot; is the first sample *not* to save, so we need +1&#39;s here</span>
        <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tmax</span><span class="p">),</span> <span class="n">use_rounding</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_buffer_size</span><span class="p">(</span><span class="n">buffer_size_sec</span><span class="p">)</span>

        <span class="c1"># write the raw file</span>
        <span class="k">if</span> <span class="n">split_naming</span> <span class="o">==</span> <span class="s1">&#39;neuromag&#39;</span><span class="p">:</span>
            <span class="n">part_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">split_naming</span> <span class="o">==</span> <span class="s1">&#39;bids&#39;</span><span class="p">:</span>
            <span class="n">part_idx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;split_naming must be either &#39;neuromag&#39; or &#39;bids&#39; instead &quot;</span>
                <span class="s2">&quot;of &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">split_naming</span><span class="p">))</span>
        <span class="n">_write_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span>
                   <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span>
                   <span class="n">split_size</span><span class="p">,</span> <span class="n">split_naming</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
             <span class="n">bgcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bad_color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
             <span class="n">event_color</span><span class="o">=</span><span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">show_options</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">highpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lowpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filtorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">clipping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">show_first_samp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">group_by</span><span class="o">=</span><span class="s1">&#39;type&#39;</span><span class="p">,</span>
             <span class="n">butterfly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">decim</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">bgcolor</span><span class="p">,</span>
                        <span class="n">color</span><span class="p">,</span> <span class="n">bad_color</span><span class="p">,</span> <span class="n">event_color</span><span class="p">,</span> <span class="n">scalings</span><span class="p">,</span> <span class="n">remove_dc</span><span class="p">,</span>
                        <span class="n">order</span><span class="p">,</span> <span class="n">show_options</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">show</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">highpass</span><span class="p">,</span>
                        <span class="n">lowpass</span><span class="p">,</span> <span class="n">filtorder</span><span class="p">,</span> <span class="n">clipping</span><span class="p">,</span> <span class="n">show_first_samp</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span>
                        <span class="n">group_by</span><span class="p">,</span> <span class="n">butterfly</span><span class="p">,</span> <span class="n">decim</span><span class="p">,</span> <span class="n">noise_cov</span><span class="o">=</span><span class="n">noise_cov</span><span class="p">,</span>
                        <span class="n">event_id</span><span class="o">=</span><span class="n">event_id</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw_psd</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                 <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">area_mode</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="n">area_alpha</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
                 <span class="n">n_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">estimate</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">line_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spatial_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">xscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw_psd</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
            <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">area_mode</span><span class="o">=</span><span class="n">area_mode</span><span class="p">,</span>
            <span class="n">area_alpha</span><span class="o">=</span><span class="n">area_alpha</span><span class="p">,</span> <span class="n">n_overlap</span><span class="o">=</span><span class="n">n_overlap</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span>
            <span class="n">estimate</span><span class="o">=</span><span class="n">estimate</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">line_alpha</span><span class="o">=</span><span class="n">line_alpha</span><span class="p">,</span> <span class="n">spatial_colors</span><span class="o">=</span><span class="n">spatial_colors</span><span class="p">,</span>
            <span class="n">xscale</span><span class="o">=</span><span class="n">xscale</span><span class="p">,</span> <span class="n">reject_by_annotation</span><span class="o">=</span><span class="n">reject_by_annotation</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_raw_psd_topo</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">n_fft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">n_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                      <span class="n">fig_facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">axis_facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_raw_psd_topo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                                 <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">,</span>
                                 <span class="n">n_overlap</span><span class="o">=</span><span class="n">n_overlap</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">fig_facecolor</span><span class="o">=</span><span class="n">fig_facecolor</span><span class="p">,</span>
                                 <span class="n">axis_facecolor</span><span class="o">=</span><span class="n">axis_facecolor</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span>
                                 <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                                 <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;raw.estimate_rank is deprecated and will be removed in 0.19, &#39;</span>
                <span class="s1">&#39;use mne.compute_rank instead.&#39;</span><span class="p">)</span>
    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">estimate_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstart</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tstop</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                      <span class="n">return_singular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate rank of the raw data.</span>

<span class="sd">        This function is meant to provide a reasonable estimate of the rank.</span>
<span class="sd">        The true rank of the data depends on many factors, so use at your</span>
<span class="sd">        own risk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstart : float</span>
<span class="sd">            Start time to use for rank estimation. Default is 0.0.</span>
<span class="sd">        tstop : float | None</span>
<span class="sd">            End time to use for rank estimation. Default is 30.0.</span>
<span class="sd">            If None, the end time of the raw file is used.</span>
<span class="sd">        tol : float</span>
<span class="sd">            Tolerance for singular values to consider non-zero in</span>
<span class="sd">            calculating the rank. The singular values are calculated</span>
<span class="sd">            in this method such that independent data are expected to</span>
<span class="sd">            have singular value around one.</span>
<span class="sd">        return_singular : bool</span>
<span class="sd">            If True, also return the singular values that were used</span>
<span class="sd">            to determine the rank.</span>
<span class="sd">        %(picks_good_data)s</span>
<span class="sd">        scalings : dict | &#39;norm&#39; | None</span>
<span class="sd">            To achieve reliable rank estimation on multiple sensors,</span>
<span class="sd">            sensors have to be rescaled. This parameter controls the</span>
<span class="sd">            rescaling. If dict, it will update the</span>
<span class="sd">            following dict of defaults:</span>

<span class="sd">                dict(mag=1e11, grad=1e9, eeg=1e5)</span>

<span class="sd">            If &#39;norm&#39; data will be scaled by internally computed</span>
<span class="sd">            channel-wise norms. None will perform no scaling.</span>
<span class="sd">            Defaults to &#39;norm&#39;.</span>
<span class="sd">        %(verbose)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rank : int</span>
<span class="sd">            Estimated rank of the data.</span>
<span class="sd">        s : array</span>
<span class="sd">            If return_singular is True, the singular values that were</span>
<span class="sd">            thresholded to determine the rank are also returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If data are not pre-loaded, the appropriate data will be loaded</span>
<span class="sd">        by this function (can be memory intensive).</span>

<span class="sd">        Projectors are not taken into account unless they have been applied</span>
<span class="sd">        to the data using apply_proj(), since it is not always possible</span>
<span class="sd">        to tell whether or not projectors have been applied previously.</span>

<span class="sd">        Bad channels will be excluded from calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..rank</span> <span class="k">import</span> <span class="n">_estimate_rank_meeg_signals</span>

        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">tstart</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tstop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_times</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_as_index</span><span class="p">(</span><span class="n">tstop</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tslice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">with_ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ensure we don&#39;t get a view of data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span>
        <span class="c1"># this should already be a copy, so we can overwrite it</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">tslice</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_estimate_rank_meeg_signals</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">),</span>
            <span class="n">scalings</span><span class="o">=</span><span class="n">scalings</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">return_singular</span><span class="o">=</span><span class="n">return_singular</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Channel names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of time points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of time points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        len : int</span>
<span class="sd">            The number of time points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This can be used as::</span>

<span class="sd">            &gt;&gt;&gt; len(raw)  # doctest: +SKIP</span>
<span class="sd">            1000</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span>

    <span class="k">def</span> <span class="nf">load_bad_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bad_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark channels as bad from a text file.</span>

<span class="sd">        This function operates mostly in the style of the C function</span>
<span class="sd">        ``mne_mark_bad_channels``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bad_file : string</span>
<span class="sd">            File name of the text file containing bad channels</span>
<span class="sd">            If bad_file = None, bad channels are cleared, but this</span>
<span class="sd">            is more easily done directly as raw.info[&#39;bads&#39;] = [].</span>
<span class="sd">        force : boolean</span>
<span class="sd">            Whether or not to force bad channel marking (of those</span>
<span class="sd">            that exist) if channels are not found, instead of</span>
<span class="sd">            raising an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bad_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check to make sure bad channels are there</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bad_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
                <span class="n">bad_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">fid</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">l</span><span class="p">]</span>
            <span class="n">names_there</span> <span class="o">=</span> <span class="p">[</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">bad_names</span> <span class="k">if</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            <span class="n">count_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">names_there</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">count_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad channels from:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1"> not found &#39;</span>
                                     <span class="s1">&#39;in:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bad_file</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> bad channels from:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">not found in:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">count_diff</span><span class="p">,</span> <span class="n">bad_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">names_there</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raws</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate raw instances as if they were continuous.</span>

<span class="sd">        .. note:: Boundaries of the raw files are annotated bad. If you wish to</span>
<span class="sd">                  use the data as continuous recording, you can remove the</span>
<span class="sd">                  boundary annotations after concatenation (see</span>
<span class="sd">                  :meth:`mne.Annotations.delete`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raws : list, or Raw instance</span>
<span class="sd">            list of Raw instances to concatenate to the current instance</span>
<span class="sd">            (in order), or a single raw instance to concatenate.</span>
<span class="sd">        preload : bool, str, or None (default None)</span>
<span class="sd">            Preload data into memory for data manipulation and faster indexing.</span>
<span class="sd">            If True, the data will be preloaded into memory (fast, requires</span>
<span class="sd">            large amount of memory). If preload is a string, preload is the</span>
<span class="sd">            file name of a memory-mapped file which is used to store the data</span>
<span class="sd">            on the hard drive (slower, requires less memory). If preload is</span>
<span class="sd">            None, preload=True or False is inferred using the preload status</span>
<span class="sd">            of the raw files passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raws</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">raws</span> <span class="o">=</span> <span class="p">[</span><span class="n">raws</span><span class="p">]</span>

        <span class="c1"># make sure the raws are compatible</span>
        <span class="n">all_raws</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">all_raws</span> <span class="o">+=</span> <span class="n">raws</span>
        <span class="n">_check_raw_compatibility</span><span class="p">(</span><span class="n">all_raws</span><span class="p">)</span>

        <span class="c1"># deal with preloading data first (while files are separate)</span>
        <span class="n">all_preloaded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">preload</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">all_preloaded</span><span class="p">:</span>
                <span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">preload</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do the concatenation ourselves since preload might be a string</span>
            <span class="n">nchan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span>
            <span class="n">c_ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">rr</span><span class="o">.</span><span class="n">n_times</span> <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">raws</span><span class="p">)])</span>
            <span class="n">nsamp</span> <span class="o">=</span> <span class="n">c_ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="n">this_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

            <span class="c1"># allocate the buffer</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">preload</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">this_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">this_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">c_ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">this_data</span>

            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                    <span class="c1"># read the data directly into the buffer</span>
                    <span class="n">data_buffer</span> <span class="o">=</span> <span class="n">_data</span><span class="p">[:,</span> <span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_read_segment</span><span class="p">(</span><span class="n">data_buffer</span><span class="o">=</span><span class="n">data_buffer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_data</span><span class="p">[:,</span> <span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span><span class="p">]:</span><span class="n">c_ns</span><span class="p">[</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">raws</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># now combine information from each raw file to construct new self</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
        <span class="n">edge_samps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">raws</span><span class="p">):</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">r_annot</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">(</span><span class="n">onset</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">-</span> <span class="n">r</span><span class="o">.</span><span class="n">_first_time</span><span class="p">,</span>
                                  <span class="n">duration</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
                                  <span class="n">description</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                                  <span class="n">orig_time</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="n">_combine_annotations</span><span class="p">(</span>
                <span class="n">annotations</span><span class="p">,</span> <span class="n">r_annot</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_date&#39;</span><span class="p">])</span>
            <span class="n">edge_samps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)</span> <span class="o">-</span>
                              <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span> <span class="o">+=</span> <span class="n">r</span><span class="o">.</span><span class="n">_raw_extras</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span> <span class="o">+=</span> <span class="n">r</span><span class="o">.</span><span class="n">_filenames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_times</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge_samp</span> <span class="ow">in</span> <span class="n">edge_samps</span><span class="p">:</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="n">_sync_onset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">edge_samp</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s1">&#39;BAD boundary&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="s1">&#39;EDGE boundary&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_samps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_samps</span><span class="p">)</span> <span class="o">==</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_extras</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filenames</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Append error&#39;</span><span class="p">)</span>  <span class="c1"># should never happen</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up the object.</span>

<span class="sd">        Does nothing for objects that close their file descriptors.</span>
<span class="sd">        Things like RawFIF will override this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of Raw instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D105</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">size_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sizeof_fmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">))</span>  <span class="c1"># str in case it fails -&gt; None</span>
        <span class="n">size_str</span> <span class="o">+=</span> <span class="s1">&#39;, data</span><span class="si">%s</span><span class="s1"> loaded&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="k">else</span> <span class="s1">&#39; not&#39;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, n_channels x n_times : </span><span class="si">%s</span><span class="s1"> x </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%0.1f</span><span class="s1"> sec), ~</span><span class="si">%s</span><span class="s1">&#39;</span>
             <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">size_str</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">  |  </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">stim_channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add events to stim channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        events : ndarray, shape (n_events, 3)</span>
<span class="sd">            Events to add. The first column specifies the sample number of</span>
<span class="sd">            each event, the second column is ignored, and the third column</span>
<span class="sd">            provides the event value. If events already exist in the Raw</span>
<span class="sd">            instance at the given sample numbers, the event values will be</span>
<span class="sd">            added together.</span>
<span class="sd">        stim_channel : str | None</span>
<span class="sd">            Name of the stim channel to add to. If None, the config variable</span>
<span class="sd">            &#39;MNE_STIM_CHANNEL&#39; is used. If this is not found, it will default</span>
<span class="sd">            to &#39;STI 014&#39;.</span>
<span class="sd">        replace : bool</span>
<span class="sd">            If True the old events on the stim channel are removed before</span>
<span class="sd">            adding the new ones.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Data must be preloaded in order to add events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Adding events&#39;</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events must be shape (n_events, 3)&#39;</span><span class="p">)</span>
        <span class="n">stim_channel</span> <span class="o">=</span> <span class="n">_get_stim_channel</span><span class="p">(</span><span class="n">stim_channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">pick_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">stim_channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pick</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel </span><span class="si">%s</span><span class="s1"> not found&#39;</span> <span class="o">%</span> <span class="n">stim_channel</span><span class="p">)</span>
        <span class="n">pick</span> <span class="o">=</span> <span class="n">pick</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event sample numbers must be between </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event sample numbers must be integers&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">pick</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">pick</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span><span class="p">]</span> <span class="o">+=</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_buffer_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer_size_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the buffer size.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">buffer_size_sec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer_size_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size_sec</span>
        <span class="n">buffer_size_sec</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">buffer_size_sec</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">buffer_size_sec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">_allocate_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_buffer</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allocate data in memory or in memmap for preloading.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if not already done, allocate array with right type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># use a memmap</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">data_buffer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_index_as_time</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">first_samp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_first_samp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert indices to time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : list-like | int</span>
<span class="sd">        List of ints or int representing points in time.</span>
<span class="sd">    use_first_samp : boolean</span>
<span class="sd">        If True, the time returned is relative to the session onset, else</span>
<span class="sd">        relative to the recording onset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times : ndarray</span>
<span class="sd">        Times corresponding to the index supplied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">first_samp</span> <span class="k">if</span> <span class="n">use_first_samp</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">times</span> <span class="o">/</span> <span class="n">sfreq</span>


<span class="k">class</span> <span class="nc">_RawShell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a temporary raw object.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rawdir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_samp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span>

    <span class="k">def</span> <span class="nf">set_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="n">Annotations</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_annotations</span> <span class="o">=</span> <span class="n">annotations</span>


<span class="c1">###############################################################################</span>
<span class="c1"># Writing</span>
<span class="k">def</span> <span class="nf">_write_raw</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
               <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span>
               <span class="n">split_size</span><span class="p">,</span> <span class="n">split_naming</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">prev_fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write raw file with splitting.&quot;&quot;&quot;</span>
    <span class="c1"># we&#39;ve done something wrong if we hit this</span>
    <span class="n">n_times_max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span> <span class="ow">or</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">n_times_max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot write raw file with no data: </span><span class="si">%s</span><span class="s1"> -&gt; </span><span class="si">%s</span><span class="s1"> &#39;</span>
                           <span class="s1">&#39;(max: </span><span class="si">%s</span><span class="s1">) requested&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n_times_max</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">split_naming</span> <span class="o">==</span> <span class="s1">&#39;neuromag&#39;</span><span class="p">:</span>
            <span class="c1"># insert index in filename</span>
            <span class="n">use_fname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">split_naming</span> <span class="o">==</span> <span class="s1">&#39;bids&#39;</span><span class="p">:</span>
            <span class="n">use_fname</span> <span class="o">=</span> <span class="n">_construct_bids_filename</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">)</span>
            <span class="c1"># check for file existence</span>
            <span class="n">_check_fname</span><span class="p">(</span><span class="n">use_fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_fname</span> <span class="o">=</span> <span class="n">fname</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">use_fname</span><span class="p">)</span>

    <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="p">())</span>
    <span class="n">fid</span><span class="p">,</span> <span class="n">cals</span> <span class="o">=</span> <span class="n">_start_writing_raw</span><span class="p">(</span><span class="n">use_fname</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span>
                                   <span class="n">reset_range</span><span class="p">,</span> <span class="n">raw</span><span class="o">.</span><span class="n">annotations</span><span class="p">)</span>

    <span class="n">first_samp</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">first_samp</span> <span class="o">+</span> <span class="n">start</span>
    <span class="k">if</span> <span class="n">first_samp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_FIRST_SAMPLE</span><span class="p">,</span> <span class="n">first_samp</span><span class="p">)</span>

    <span class="c1"># previous file name and id</span>
    <span class="k">if</span> <span class="n">split_naming</span> <span class="o">==</span> <span class="s1">&#39;neuromag&#39;</span><span class="p">:</span>
        <span class="n">part_idx_tag</span> <span class="o">=</span> <span class="n">part_idx</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part_idx_tag</span> <span class="o">=</span> <span class="n">part_idx</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_ROLE</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ROLE_PREV_FILE</span><span class="p">)</span>
        <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NAME</span><span class="p">,</span> <span class="n">prev_fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NUM</span><span class="p">,</span> <span class="n">part_idx_tag</span><span class="p">)</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>

    <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pos_prev</span> <span class="o">&gt;</span> <span class="n">split_size</span><span class="p">:</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;file is larger than &quot;split_size&quot; after writing &#39;</span>
                         <span class="s1">&#39;measurement information, you must use a larger &#39;</span>
                         <span class="s1">&#39;value for split size: </span><span class="si">%s</span><span class="s1"> plus enough bytes for &#39;</span>
                         <span class="s1">&#39;the chosen buffer_size&#39;</span> <span class="o">%</span> <span class="n">pos_prev</span><span class="p">)</span>
    <span class="n">next_file_buffer</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span>  <span class="c1"># extra cushion for last few post-data tags</span>

    <span class="c1"># Check to see if this has acquisition skips and, if so, if we can</span>
    <span class="c1"># write out empty buffers instead of zeroes</span>
    <span class="n">firsts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">))</span>
    <span class="n">lasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">firsts</span><span class="p">)</span> <span class="o">+</span> <span class="n">buffer_size</span>
    <span class="k">if</span> <span class="n">lasts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>
        <span class="n">lasts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stop</span>
    <span class="n">sk_onsets</span><span class="p">,</span> <span class="n">sk_ends</span> <span class="o">=</span> <span class="n">_annotations_starts_stops</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="s1">&#39;bad_acq_skip&#39;</span><span class="p">)</span>
    <span class="n">do_skips</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_onsets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">sk_onsets</span><span class="p">,</span> <span class="n">firsts</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">sk_ends</span><span class="p">,</span> <span class="n">lasts</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">do_skips</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Acquisition skips detected but did not fit evenly into &#39;</span>
                     <span class="s1">&#39;output buffer_size, will be written as zeroes.&#39;</span><span class="p">)</span>

    <span class="n">n_current_skip</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">firsts</span><span class="p">,</span> <span class="n">lasts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">do_skips</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">sk_onsets</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">last</span> <span class="o">&lt;=</span> <span class="n">sk_ends</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># Track how many we have</span>
                <span class="n">n_current_skip</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">n_current_skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Write out an empty buffer instead of data</span>
                <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_DATA_SKIP</span><span class="p">,</span> <span class="n">n_current_skip</span><span class="p">)</span>
                <span class="c1"># These two NOPs appear to be optional (MaxFilter does not do</span>
                <span class="c1"># it, but some acquisition machines do) so let&#39;s not bother.</span>
                <span class="c1"># write_nop(fid)</span>
                <span class="c1"># write_nop(fid)</span>
                <span class="n">n_current_skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span>

        <span class="k">if</span> <span class="n">projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projector</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">drop_small_buffer</span> <span class="ow">and</span> <span class="p">(</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="ow">and</span>
             <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">))):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skipping data chunk due to small buffer ... &#39;</span>
                        <span class="s1">&#39;[done]&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Writing ...&#39;</span><span class="p">)</span>
        <span class="n">_write_raw_buffer</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="n">this_buff_size_bytes</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">pos_prev</span>
        <span class="n">overage</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">split_size</span> <span class="o">+</span> <span class="n">next_file_buffer</span>
        <span class="k">if</span> <span class="n">overage</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This should occur on the first buffer write of the file, so</span>
            <span class="c1"># we should mention the space required for the meas info</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;buffer size (</span><span class="si">%s</span><span class="s1">) is too large for the given split size (</span><span class="si">%s</span><span class="s1">) &#39;</span>
                <span class="s1">&#39;by </span><span class="si">%s</span><span class="s1"> bytes after writing info (</span><span class="si">%s</span><span class="s1">) and leaving enough space &#39;</span>
                <span class="s1">&#39;for end tags (</span><span class="si">%s</span><span class="s1">): decrease &quot;buffer_size_sec&quot; or increase &#39;</span>
                <span class="s1">&#39;&quot;split_size&quot;.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">this_buff_size_bytes</span><span class="p">,</span> <span class="n">split_size</span><span class="p">,</span> <span class="n">overage</span><span class="p">,</span>
                                   <span class="n">pos_prev</span><span class="p">,</span> <span class="n">next_file_buffer</span><span class="p">))</span>

        <span class="c1"># Split files if necessary, leave some space for next file info</span>
        <span class="c1"># make sure we check to make sure we actually *need* another buffer</span>
        <span class="c1"># with the &quot;and&quot; check</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">split_size</span> <span class="o">-</span> <span class="n">this_buff_size_bytes</span> <span class="o">-</span> <span class="n">next_file_buffer</span> <span class="ow">and</span> \
                <span class="n">first</span> <span class="o">+</span> <span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">next_fname</span><span class="p">,</span> <span class="n">next_idx</span> <span class="o">=</span> <span class="n">_write_raw</span><span class="p">(</span>
                <span class="n">fname</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span>
                <span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span>
                <span class="n">projector</span><span class="p">,</span> <span class="n">drop_small_buffer</span><span class="p">,</span> <span class="n">split_size</span><span class="p">,</span> <span class="n">split_naming</span><span class="p">,</span>
                <span class="n">part_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">use_fname</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

            <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
            <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_ROLE</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ROLE_NEXT_FILE</span><span class="p">)</span>
            <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NAME</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">next_fname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>
            <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NUM</span><span class="p">,</span> <span class="n">next_idx</span><span class="p">)</span>
            <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">pos_prev</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Closing </span><span class="si">%s</span><span class="s1"> [done]&#39;</span> <span class="o">%</span> <span class="n">use_fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxshield&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_SMSH_RAW_DATA</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_RAW_DATA</span><span class="p">)</span>
    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">end_file</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">use_fname</span><span class="p">,</span> <span class="n">part_idx</span>


<span class="k">def</span> <span class="nf">_start_writing_raw</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span>
                       <span class="n">reset_range</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Start write raw data in file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : string</span>
<span class="sd">        Name of the file to create.</span>
<span class="sd">    info : dict</span>
<span class="sd">        Measurement info.</span>
<span class="sd">    sel : array of int | None</span>
<span class="sd">        Indices of channels to include. If None, all channels</span>
<span class="sd">        are included.</span>
<span class="sd">    data_type : int</span>
<span class="sd">        The data_type in case it is necessary. Should be 4 (FIFFT_FLOAT),</span>
<span class="sd">        5 (FIFFT_DOUBLE), 16 (FIFFT_DAU_PACK16), or 3 (FIFFT_INT) for raw data.</span>
<span class="sd">    reset_range : bool</span>
<span class="sd">        If True, the info[&#39;chs&#39;][k][&#39;range&#39;] parameter will be set to unity.</span>
<span class="sd">    annotations : instance of Annotations</span>
<span class="sd">        The annotations to write.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fid : file</span>
<span class="sd">        The file descriptor.</span>
<span class="sd">    cals : list</span>
<span class="sd">        calibration factors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># Measurement info</span>
    <span class="c1">#</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">pick_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">sel</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Create the file and save the essentials</span>
    <span class="c1">#</span>
    <span class="n">fid</span> <span class="o">=</span> <span class="n">start_file</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_BLOCK_ID</span><span class="p">)</span>
    <span class="c1"># XXX do we need this?</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_PARENT_BLOCK_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>

    <span class="n">cals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]):</span>
        <span class="c1">#</span>
        <span class="c1">#   Scan numbers may have been messed up</span>
        <span class="c1">#</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scanno&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># scanno starts at 1 in FIF format</span>
        <span class="k">if</span> <span class="n">reset_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;range&#39;</span><span class="p">])</span>

    <span class="n">write_meas_info</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="n">reset_range</span><span class="o">=</span><span class="n">reset_range</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Annotations</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># don&#39;t save empty annot</span>
        <span class="n">_write_annotations</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Start the raw data</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;maxshield&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_SMSH_RAW_DATA</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_RAW_DATA</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">cals</span>


<span class="k">def</span> <span class="nf">_write_raw_buffer</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cals</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write raw buffer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fid : file descriptor</span>
<span class="sd">        an open raw data file.</span>
<span class="sd">    buf : array</span>
<span class="sd">        The buffer to write.</span>
<span class="sd">    cals : array</span>
<span class="sd">        Calibration factors.</span>
<span class="sd">    fmt : str</span>
<span class="sd">        &#39;short&#39;, &#39;int&#39;, &#39;single&#39;, or &#39;double&#39; for 16/32 bit int or 32/64 bit</span>
<span class="sd">        float for each item. This will be doubled for complex datatypes. Note</span>
<span class="sd">        that short and int formats cannot be used for complex data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">buf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cals</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;buffer and calibration sizes do not match&#39;</span><span class="p">)</span>

    <span class="n">_check_option</span><span class="p">(</span><span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;short&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="s1">&#39;double&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">buf</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;short&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_dau_pack16</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_int</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_float</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_double</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_complex64</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;double&#39;</span><span class="p">:</span>
            <span class="n">write_function</span> <span class="o">=</span> <span class="n">write_complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only &quot;single&quot; and &quot;double&quot; supported for &#39;</span>
                             <span class="s1">&#39;writing complex data&#39;</span><span class="p">)</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">cals</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">write_function</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_DATA_BUFFER</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_raw_compatibility</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure all instances of Raw have compatible parameters.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">] type must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">nchan</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">bads</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">sfreq</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">ch_names</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">_cals</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_cals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;raw[</span><span class="si">%d</span><span class="s1">]._cals must match&#39;</span> <span class="o">%</span> <span class="n">ri</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in raw files must be the same&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_proj_equal</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span>
                   <span class="nb">zip</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in raw files must be the same&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">==</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">orig_format</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raw</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;raw files do not all have the same data format, could result in &#39;</span>
             <span class="s1">&#39;precision mismatch. Setting raw.orig_format=&quot;unknown&quot;&#39;</span><span class="p">)</span>
        <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">orig_format</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">concatenate_raws</span><span class="p">(</span><span class="n">raws</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">events_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate raw instances as if they were continuous.</span>

<span class="sd">    .. note:: ``raws[0]`` is modified in-place to achieve the concatenation.</span>
<span class="sd">              Boundaries of the raw files are annotated bad. If you wish to use</span>
<span class="sd">              the data as continuous recording, you can remove the boundary</span>
<span class="sd">              annotations after concatenation (see</span>
<span class="sd">              :meth:`mne.Annotations.delete`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raws : list</span>
<span class="sd">        list of Raw instances to concatenate (in order).</span>
<span class="sd">    preload : bool, or None</span>
<span class="sd">        If None, preload status is inferred using the preload status of the</span>
<span class="sd">        raw files passed in. True or False sets the resulting raw file to</span>
<span class="sd">        have or not have data preloaded.</span>
<span class="sd">    events_list : None | list</span>
<span class="sd">        The events to concatenate. Defaults to None.</span>
<span class="sd">    %(verbose)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    raw : instance of Raw</span>
<span class="sd">        The result of the concatenation (first Raw instance passed in).</span>
<span class="sd">    events : ndarray of int, shape (n_events, 3)</span>
<span class="sd">        The events. Only returned if `event_list` is not None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">events_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raws</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`raws` and `event_list` are required &#39;</span>
                             <span class="s1">&#39;to be of the same length&#39;</span><span class="p">)</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">r</span><span class="o">.</span><span class="n">first_samp</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">last_samp</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">raws</span><span class="p">])</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">concatenate_events</span><span class="p">(</span><span class="n">events_list</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
    <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">preload</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">events_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">events</span>


<span class="k">def</span> <span class="nf">_check_update_montage</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_ch_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">raise_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Help eeg readers to add montage.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">montage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Montage</span><span class="p">)):</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Montage must be str, None, or instance of Montage. &quot;</span>
                   <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> was provided&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">montage</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">montage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">montage</span> <span class="o">=</span> <span class="n">read_montage</span><span class="p">(</span><span class="n">montage</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
            <span class="n">_set_montage</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">update_ch_names</span><span class="o">=</span><span class="n">update_ch_names</span><span class="p">)</span>

            <span class="n">missing_positions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EOG_CH</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MISC_CH</span><span class="p">,</span>
                       <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_STIM_CH</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">missing_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">])</span>

            <span class="c1"># raise error if positions are missing</span>
            <span class="k">if</span> <span class="n">missing_positions</span> <span class="ow">and</span> <span class="n">raise_missing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s2">&quot;The following positions are missing from the montage &quot;</span>
                    <span class="s2">&quot;definitions: </span><span class="si">%s</span><span class="s2">. If those channels lack positions &quot;</span>
                    <span class="s2">&quot;because they are EOG channels use the eog parameter.&quot;</span>
                    <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing_positions</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_check_maxshield</span><span class="p">(</span><span class="n">allow_maxshield</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Warn or error about MaxShield.&quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;This file contains raw Internal Active &#39;</span>
           <span class="s1">&#39;Shielding data. It may be distorted. Elekta &#39;</span>
           <span class="s1">&#39;recommends it be run through MaxFilter to &#39;</span>
           <span class="s1">&#39;produce reliable results. Consider closing &#39;</span>
           <span class="s1">&#39;the file and running MaxFilter on the data.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_maxshield</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">allow_maxshield</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">allow_maxshield</span> <span class="o">==</span> <span class="s1">&#39;yes&#39;</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39; Use allow_maxshield=True if you are sure you&#39;</span>
                <span class="s1">&#39; want to load the data despite this warning.&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-05-21

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>