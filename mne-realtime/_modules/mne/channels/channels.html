

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mne.channels.channels &mdash; MNE-Realtime 0.0.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/project-template.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> MNE-Realtime
          

          
            
            <img src="../../../_static/mne_logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User guide: create your own mne project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">mne-realtime API</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial - Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Real-time M/EEG Acquisition</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MNE-Realtime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mne.channels.channels</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mne.channels.channels</h1><div class="highlight"><pre>
<span></span><span class="c1"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Matti Hamalainen &lt;msh@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Denis Engemann &lt;denis.engemann@gmail.com&gt;</span>
<span class="c1">#          Andrew Dykstra &lt;andrew.r.dykstra@gmail.com&gt;</span>
<span class="c1">#          Teon Brooks &lt;teon.brooks@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>

<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">copy_function_doc_to_method_doc</span><span class="p">,</span>
                     <span class="n">_check_preload</span><span class="p">,</span> <span class="n">_validate_type</span><span class="p">,</span> <span class="n">fill_doc</span><span class="p">,</span> <span class="n">_check_option</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..io.compensator</span> <span class="k">import</span> <span class="n">get_current_comp</span>
<span class="kn">from</span> <span class="nn">..io.constants</span> <span class="k">import</span> <span class="n">FIFF</span>
<span class="kn">from</span> <span class="nn">..io.meas_info</span> <span class="k">import</span> <span class="n">anonymize_info</span><span class="p">,</span> <span class="n">Info</span>
<span class="kn">from</span> <span class="nn">..io.pick</span> <span class="k">import</span> <span class="p">(</span><span class="n">channel_type</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">,</span> <span class="n">pick_types</span><span class="p">,</span> <span class="n">_picks_by_type</span><span class="p">,</span>
                       <span class="n">_check_excludes_includes</span><span class="p">,</span> <span class="n">_contains_ch_type</span><span class="p">,</span>
                       <span class="n">channel_indices_by_type</span><span class="p">,</span> <span class="n">pick_channels</span><span class="p">,</span> <span class="n">_picks_to_idx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_meg_system</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Educated guess for the helmet type based on channels.&quot;&quot;&quot;</span>
    <span class="n">have_helmet</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MEG_CH</span><span class="p">:</span>
            <span class="c1"># Only take first 16 bits, as higher bits store CTF grad comp order</span>
            <span class="n">coil_type</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span>
            <span class="k">if</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_NM_122</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;122m&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">//</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># All Vectorview coils are 30xx</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;306m&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_MAG</span> <span class="ow">or</span>
                  <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_GRAD</span><span class="p">):</span>
                <span class="n">nmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MEG_CH</span>
                               <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]])</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;Magnes_3600wh&#39;</span> <span class="k">if</span> <span class="n">nmag</span> <span class="o">&gt;</span> <span class="mi">150</span> <span class="k">else</span> <span class="s1">&#39;Magnes_2500wh&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;CTF_275&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_KIT_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;KIT&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_BABY_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;BabySQUID&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">coil_type</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_ARTEMIS123_GRAD</span><span class="p">:</span>
                <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;ARTEMIS123&#39;</span>
                <span class="n">have_helmet</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>
        <span class="n">have_helmet</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">system</span><span class="p">,</span> <span class="n">have_helmet</span>


<span class="k">def</span> <span class="nf">_get_ch_type</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">,</span> <span class="n">allow_ref_meg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choose a single channel type (usually for plotting).</span>

<span class="sd">    Usually used in plotting to plot a single datatype, e.g. look for mags,</span>
<span class="sd">    then grads, then ... to plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">allowed_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">,</span> <span class="s1">&#39;planar1&#39;</span><span class="p">,</span> <span class="s1">&#39;planar2&#39;</span><span class="p">,</span> <span class="s1">&#39;eeg&#39;</span><span class="p">]</span>
        <span class="n">allowed_types</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;ref_meg&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">allow_ref_meg</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">allowed_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">Info</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_contains_ch_type</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
                    <span class="n">ch_type</span> <span class="o">=</span> <span class="n">type_</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">inst</span><span class="p">:</span>
                <span class="n">ch_type</span> <span class="o">=</span> <span class="n">type_</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No plottable channel types found&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch_type</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">equalize_channels</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equalize channel picks for a collection of MNE-Python objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    candidates : list</span>
<span class="sd">        list Raw | Epochs | Evoked | AverageTFR</span>
<span class="sd">    %(verbose)s</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function operates inplace.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..io.base</span> <span class="k">import</span> <span class="n">BaseRaw</span>
    <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>
    <span class="kn">from</span> <span class="nn">..evoked</span> <span class="k">import</span> <span class="n">Evoked</span>
    <span class="kn">from</span> <span class="nn">..time_frequency</span> <span class="k">import</span> <span class="n">_BaseTFR</span>

    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span>
                       <span class="p">(</span><span class="n">BaseRaw</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">,</span> <span class="n">Evoked</span><span class="p">,</span> <span class="n">_BaseTFR</span><span class="p">),</span>
                       <span class="s2">&quot;Instances to be modified&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Raw, Epochs, Evoked or TFR&quot;</span><span class="p">)</span>

    <span class="n">chan_max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">])</span>
    <span class="n">chan_template</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="n">chan_max_idx</span><span class="p">]</span><span class="o">.</span><span class="n">ch_names</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Identifying common channels ...&#39;</span><span class="p">)</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="n">common_channels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chan_template</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">channels</span><span class="p">)</span>
    <span class="n">dropped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="n">drop_them</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">common_channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_them</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">drop_channels</span><span class="p">(</span><span class="n">drop_them</span><span class="p">)</span>
            <span class="n">dropped</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">drop_them</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dropped</span><span class="p">:</span>
        <span class="n">dropped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dropped</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dropped the following channels:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dropped</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;all channels are corresponding, nothing to do.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ContainsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check channel type membership.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_type : str</span>
<span class="sd">            Channel type to check for. Can be e.g. &#39;meg&#39;, &#39;eeg&#39;, &#39;stim&#39;, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        in : bool</span>
<span class="sd">            Whether or not the instance contains the given channel type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Channel type membership can be tested as::</span>

<span class="sd">            &gt;&gt;&gt; &#39;meg&#39; in inst  # doctest: +SKIP</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; &#39;seeg&#39; in inst  # doctest: +SKIP</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;meg&#39;</span><span class="p">:</span>
            <span class="n">has_ch_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;mag&#39;</span><span class="p">)</span> <span class="ow">or</span>
                           <span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_ch_type</span> <span class="o">=</span> <span class="n">_contains_ch_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_ch_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">compensation_grade</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The current gradient compensation grade.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_current_comp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>


<span class="c1"># XXX Eventually de-duplicate with _kind_dict of mne/io/meas_info.py</span>
<span class="n">_human2fiff</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ecg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ECG_CH</span><span class="p">,</span>
               <span class="s1">&#39;eeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EEG_CH</span><span class="p">,</span>
               <span class="s1">&#39;emg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EMG_CH</span><span class="p">,</span>
               <span class="s1">&#39;eog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EOG_CH</span><span class="p">,</span>
               <span class="s1">&#39;exci&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EXCI_CH</span><span class="p">,</span>
               <span class="s1">&#39;ias&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_IAS_CH</span><span class="p">,</span>
               <span class="s1">&#39;misc&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MISC_CH</span><span class="p">,</span>
               <span class="s1">&#39;resp&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_RESP_CH</span><span class="p">,</span>
               <span class="s1">&#39;seeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_SEEG_CH</span><span class="p">,</span>
               <span class="s1">&#39;stim&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_STIM_CH</span><span class="p">,</span>
               <span class="s1">&#39;syst&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_SYST_CH</span><span class="p">,</span>
               <span class="s1">&#39;bio&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_BIO_CH</span><span class="p">,</span>
               <span class="s1">&#39;ecog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ECOG_CH</span><span class="p">,</span>
               <span class="s1">&#39;hbo&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_FNIRS_CH</span><span class="p">,</span>
               <span class="s1">&#39;hbr&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_FNIRS_CH</span><span class="p">}</span>
<span class="n">_human2unit</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ecg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;eeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;emg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;eog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;exci&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;ias&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;misc&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;resp&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;seeg&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;stim&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;syst&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">,</span>
               <span class="s1">&#39;bio&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;ecog&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">,</span>
               <span class="s1">&#39;hbo&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">,</span>
               <span class="s1">&#39;hbr&#39;</span><span class="p">:</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">}</span>
<span class="n">_unit2human</span> <span class="o">=</span> <span class="p">{</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_V</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_T</span><span class="p">:</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_T_M</span><span class="p">:</span> <span class="s1">&#39;T/m&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_MOL</span><span class="p">:</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span>
               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_UNIT_NONE</span><span class="p">:</span> <span class="s1">&#39;NA&#39;</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_check_set</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">projs</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensure type change is compatible with projectors.&quot;&quot;&quot;</span>
    <span class="n">new_kind</span> <span class="o">=</span> <span class="n">_human2fiff</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_kind</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="n">projs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;col_names&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot change channel type for channel </span><span class="si">%s</span><span class="s1"> &#39;</span>
                                   <span class="s1">&#39;in projector &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                                   <span class="o">%</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">],</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">]))</span>
    <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_kind</span>


<span class="k">class</span> <span class="nc">SetChannelsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">set_eeg_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_channels</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specify which reference to use for EEG data.</span>

<span class="sd">        By default, MNE-Python will automatically re-reference the EEG signal</span>
<span class="sd">        to use an average reference (see below). Use this function to</span>
<span class="sd">        explicitly specify the desired reference for EEG. This can be either an</span>
<span class="sd">        existing electrode or a new virtual channel. This function will</span>
<span class="sd">        re-reference the data according to the desired reference and prevent</span>
<span class="sd">        MNE-Python from automatically adding an average reference projection.</span>

<span class="sd">        Some common referencing schemes and the corresponding value for the</span>
<span class="sd">        ``ref_channels`` parameter:</span>

<span class="sd">        No re-referencing:</span>
<span class="sd">            If the EEG data is already using the proper reference, set</span>
<span class="sd">            ``ref_channels=[]``. This will prevent MNE-Python from</span>
<span class="sd">            automatically adding an average reference projection.</span>

<span class="sd">        Average reference:</span>
<span class="sd">            A new virtual reference electrode is created by averaging the</span>
<span class="sd">            current EEG signal by setting ``ref_channels=&#39;average&#39;``. Bad EEG</span>
<span class="sd">            channels are automatically excluded if they are properly set in</span>
<span class="sd">            ``info[&#39;bads&#39;]``.</span>

<span class="sd">        A single electrode:</span>
<span class="sd">            Set ``ref_channels`` to a list containing the name of the channel</span>
<span class="sd">            that will act as the new reference, for example</span>
<span class="sd">            ``ref_channels=[&#39;Cz&#39;]``.</span>

<span class="sd">        The mean of multiple electrodes:</span>
<span class="sd">            A new virtual reference electrode is created by computing the</span>
<span class="sd">            average of the current EEG signal recorded from two or more</span>
<span class="sd">            selected channels. Set ``ref_channels`` to a list of channel names,</span>
<span class="sd">            indicating which channels to use. For example, to apply an average</span>
<span class="sd">            mastoid reference, when using the 10-20 naming scheme, set</span>
<span class="sd">            ``ref_channels=[&#39;M1&#39;, &#39;M2&#39;]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_channels : list of str | str</span>
<span class="sd">            The name(s) of the channel(s) used to construct the reference. To</span>
<span class="sd">            apply an average reference, specify ``&#39;average&#39;`` here (default).</span>
<span class="sd">            If an empty list is specified, the data is assumed to already have</span>
<span class="sd">            a proper reference and MNE will not attempt any re-referencing of</span>
<span class="sd">            the data. Defaults to an average reference.</span>
<span class="sd">        projection : bool</span>
<span class="sd">            If ``ref_channels=&#39;average&#39;`` this argument specifies if the</span>
<span class="sd">            average reference should be computed as a projection (True) or not</span>
<span class="sd">            (False; default). If ``projection=True``, the average reference is</span>
<span class="sd">            added as a projection and is not applied to the data (it can be</span>
<span class="sd">            applied afterwards with the ``apply_proj`` method). If</span>
<span class="sd">            ``projection=False``, the average reference is directly applied to</span>
<span class="sd">            the data. If ``ref_channels`` is not ``&#39;average&#39;``, ``projection``</span>
<span class="sd">            must be set to ``False`` (the default in this case).</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw | Epochs | Evoked</span>
<span class="sd">            Data with EEG channels re-referenced. If ``ref_channels=&#39;average&#39;``</span>
<span class="sd">            and ``projection=True`` a projection will be added instead of</span>
<span class="sd">            directly re-referencing the data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.set_bipolar_reference : Convenience function for creating bipolar</span>
<span class="sd">                                    references.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        1. If a reference is requested that is not the average reference, this</span>
<span class="sd">           function removes any pre-existing average reference projections.</span>

<span class="sd">        2. During source localization, the EEG signal should have an average</span>
<span class="sd">           reference.</span>

<span class="sd">        3. In order to apply a reference, the data must be preloaded. This is</span>
<span class="sd">           not necessary if ``ref_channels=&#39;average&#39;`` and ``projection=True``.</span>

<span class="sd">        4. For an average reference, bad EEG channels are automatically</span>
<span class="sd">           excluded if they are properly set in ``info[&#39;bads&#39;]``.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..io.reference</span> <span class="k">import</span> <span class="n">set_eeg_reference</span>
        <span class="k">return</span> <span class="n">set_eeg_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_channels</span><span class="o">=</span><span class="n">ref_channels</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_channel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get channel locations from info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : str | list | slice | None</span>
<span class="sd">            None gets good data indices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">)</span>
        <span class="n">chs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">chs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">])</span>
        <span class="n">n_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_zero</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># XXX some systems have origin (0, 0, 0)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not extract channel positions for &#39;</span>
                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> channels&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_zero</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">_set_channel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update channel locations in info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos : array-like | np.ndarray, shape (n_points, 3)</span>
<span class="sd">            The channel positions to be set.</span>
<span class="sd">        names : list of str</span>
<span class="sd">            The names of the channels to be set.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of channel positions not equal to &#39;</span>
                             <span class="s1">&#39;the number of names given.&#39;</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">pos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Channel positions must have the shape (n_points, 3) &#39;</span>
                   <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;loc&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> was not found in the info. Cannot be updated.&#39;</span>
                       <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_channel_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the sensor type of channels.</span>

<span class="sd">        Note: The following sensor types are accepted:</span>
<span class="sd">            ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,</span>
<span class="sd">            hbo, hbr</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict</span>
<span class="sd">            a dictionary mapping a channel to a sensor type (str)</span>
<span class="sd">            {&#39;EEG061&#39;: &#39;eog&#39;}.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span>

        <span class="c1"># first check and assemble clean mappings of index and name</span>
        <span class="n">unit_changes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch_name</span><span class="p">,</span> <span class="n">ch_type</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ch_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This channel name (</span><span class="si">%s</span><span class="s2">) doesn&#39;t exist in &quot;</span>
                                 <span class="s2">&quot;info.&quot;</span> <span class="o">%</span> <span class="n">ch_name</span><span class="p">)</span>

            <span class="n">c_ind</span> <span class="o">=</span> <span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_human2fiff</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This function cannot change to this &#39;</span>
                                 <span class="s1">&#39;channel type: </span><span class="si">%s</span><span class="s1">. Accepted channel types &#39;</span>
                                 <span class="s1">&#39;are </span><span class="si">%s</span><span class="s1">.&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">ch_type</span><span class="p">,</span>
                                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">_human2unit</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>
            <span class="c1"># Set sensor type</span>
            <span class="n">_check_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">ch_type</span><span class="p">)</span>
            <span class="n">unit_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>
            <span class="n">unit_new</span> <span class="o">=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unit_old</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_unit2human</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel &#39;</span><span class="si">%s</span><span class="s2">&#39; has unknown unit (</span><span class="si">%s</span><span class="s2">). Please &quot;</span>
                                 <span class="s2">&quot;fix the measurement info of your data.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">ch_name</span><span class="p">,</span> <span class="n">unit_old</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">unit_old</span> <span class="o">!=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]:</span>
                <span class="n">this_change</span> <span class="o">=</span> <span class="p">(</span><span class="n">_unit2human</span><span class="p">[</span><span class="n">unit_old</span><span class="p">],</span> <span class="n">_unit2human</span><span class="p">[</span><span class="n">unit_new</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">this_change</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unit_changes</span><span class="p">:</span>
                    <span class="n">unit_changes</span><span class="p">[</span><span class="n">this_change</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">unit_changes</span><span class="p">[</span><span class="n">this_change</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_human2unit</span><span class="p">[</span><span class="n">ch_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span> <span class="s1">&#39;seeg&#39;</span><span class="p">,</span> <span class="s1">&#39;ecog&#39;</span><span class="p">]:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_EEG</span>
            <span class="k">elif</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;hbo&#39;</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_FNIRS_HBO</span>
            <span class="k">elif</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;hbr&#39;</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_FNIRS_HBR</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coil_type</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_NONE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">c_ind</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coil_type</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The unit for channel(s) </span><span class="si">{0}</span><span class="s2"> has changed from </span><span class="si">{1}</span><span class="s2"> to </span><span class="si">{2}</span><span class="s2">.&quot;</span>
        <span class="k">for</span> <span class="n">this_change</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">unit_changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">)),</span> <span class="o">*</span><span class="n">this_change</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rename_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict | callable</span>
<span class="sd">            a dictionary mapping the old channel to a new channel name</span>
<span class="sd">            e.g. {&#39;EEG061&#39; : &#39;EEG161&#39;}. Can also be a callable function</span>
<span class="sd">            that takes and returns a string (new in version 0.10.0).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rename_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">set_montage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">set_dig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set EEG sensor configuration and head digitization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        montage : instance of Montage | instance of DigMontage | str | None</span>
<span class="sd">            The montage to use (None removes any location information).</span>
<span class="sd">        set_dig : bool</span>
<span class="sd">            If True, update the digitization information (``info[&#39;dig&#39;]``)</span>
<span class="sd">            in addition to the channel positions (``info[&#39;chs&#39;][idx][&#39;loc&#39;]``).</span>

<span class="sd">            .. versionadded: 0.15</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Operates in place.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.montage</span> <span class="k">import</span> <span class="n">_set_montage</span>
        <span class="n">_set_montage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">montage</span><span class="p">,</span> <span class="n">set_dig</span><span class="o">=</span><span class="n">set_dig</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">plot_sensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;topomap&#39;</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">show_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ch_groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_sphere</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot sensor positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kind : str</span>
<span class="sd">            Whether to plot the sensors as 3d, topomap or as an interactive</span>
<span class="sd">            sensor selection dialog. Available options &#39;topomap&#39;, &#39;3d&#39;,</span>
<span class="sd">            &#39;select&#39;. If &#39;select&#39;, a set of channels can be selected</span>
<span class="sd">            interactively by using lasso selector or clicking while holding</span>
<span class="sd">            control key. The selected channels are returned along with the</span>
<span class="sd">            figure instance. Defaults to &#39;topomap&#39;.</span>
<span class="sd">        ch_type : None | str</span>
<span class="sd">            The channel type to plot. Available options &#39;mag&#39;, &#39;grad&#39;, &#39;eeg&#39;,</span>
<span class="sd">            &#39;seeg&#39;, &#39;ecog&#39;, &#39;all&#39;. If ``&#39;all&#39;``, all the available mag, grad,</span>
<span class="sd">            eeg, seeg and ecog channels are plotted. If None (default), then</span>
<span class="sd">            channels are chosen in the order given above.</span>
<span class="sd">        title : str | None</span>
<span class="sd">            Title for the figure. If None (default), equals to ``&#39;Sensor</span>
<span class="sd">            positions (%s)&#39; % ch_type``.</span>
<span class="sd">        show_names : bool | array of str</span>
<span class="sd">            Whether to display all channel names. If an array, only the channel</span>
<span class="sd">            names in the array are shown. Defaults to False.</span>
<span class="sd">        ch_groups : &#39;position&#39; | array of shape (n_ch_groups, n_picks) | None</span>
<span class="sd">            Channel groups for coloring the sensors. If None (default), default</span>
<span class="sd">            coloring scheme is used. If &#39;position&#39;, the sensors are divided</span>
<span class="sd">            into 8 regions. See ``order`` kwarg of :func:`mne.viz.plot_raw`. If</span>
<span class="sd">            array, the channels are divided by picks given in the array.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        to_sphere : bool</span>
<span class="sd">            Whether to project the 3d locations to a sphere. When False, the</span>
<span class="sd">            sensor array appears similar as to looking downwards straight above</span>
<span class="sd">            the subject&#39;s head. Has no effect when kind=&#39;3d&#39;. Defaults to True.</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        axes : instance of Axes | instance of Axes3D | None</span>
<span class="sd">            Axes to draw the sensors to. If ``kind=&#39;3d&#39;``, axes must be an</span>
<span class="sd">            instance of Axes3D. If None (default), a new axes will be created.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        block : bool</span>
<span class="sd">            Whether to halt program execution until the figure is closed.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">            .. versionadded:: 0.13.0</span>

<span class="sd">        show : bool</span>
<span class="sd">            Show figure if True. Defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : instance of Figure</span>
<span class="sd">            Figure containing the sensor topography.</span>
<span class="sd">        selection : list</span>
<span class="sd">            A list of selected channels. Only returned if ``kind==&#39;select&#39;``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.viz.plot_layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function plots the sensor locations from the info structure using</span>
<span class="sd">        matplotlib. For drawing the sensors using mayavi see</span>
<span class="sd">        :func:`mne.viz.plot_alignment`.</span>

<span class="sd">        .. versionadded:: 0.12.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..viz.utils</span> <span class="k">import</span> <span class="n">plot_sensors</span>
        <span class="k">return</span> <span class="n">plot_sensors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="n">ch_type</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                            <span class="n">show_names</span><span class="o">=</span><span class="n">show_names</span><span class="p">,</span> <span class="n">ch_groups</span><span class="o">=</span><span class="n">ch_groups</span><span class="p">,</span>
                            <span class="n">to_sphere</span><span class="o">=</span><span class="n">to_sphere</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                            <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">anonymize_info</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">anonymize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.13.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">anonymize_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">):</span>
            <span class="c1"># XXX : anonymize should rather subtract a random date</span>
            <span class="c1"># rather than setting it to None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">orig_time</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="o">.</span><span class="n">onset</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_time</span>

        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">UpdateChannelsMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs, AverageTFR.&quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">ecg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">emg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">resp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exci</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">syst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">seeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gof</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bio</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ecog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">fnirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(),</span> <span class="n">exclude</span><span class="o">=</span><span class="s1">&#39;bads&#39;</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick some channels by type and names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meg : bool | str</span>
<span class="sd">            If True include all MEG channels. If False include None</span>
<span class="sd">            If string it can be &#39;mag&#39;, &#39;grad&#39;, &#39;planar1&#39; or &#39;planar2&#39; to select</span>
<span class="sd">            only magnetometers, all gradiometers, or a specific type of</span>
<span class="sd">            gradiometer.</span>
<span class="sd">        eeg : bool</span>
<span class="sd">            If True include EEG channels.</span>
<span class="sd">        stim : bool</span>
<span class="sd">            If True include stimulus channels.</span>
<span class="sd">        eog : bool</span>
<span class="sd">            If True include EOG channels.</span>
<span class="sd">        ecg : bool</span>
<span class="sd">            If True include ECG channels.</span>
<span class="sd">        emg : bool</span>
<span class="sd">            If True include EMG channels.</span>
<span class="sd">        ref_meg: bool | str</span>
<span class="sd">            If True include CTF / 4D reference channels. If &#39;auto&#39;, the</span>
<span class="sd">            reference channels are only included if compensations are present.</span>
<span class="sd">        misc : bool</span>
<span class="sd">            If True include miscellaneous analog channels.</span>
<span class="sd">        resp : bool</span>
<span class="sd">            If True include response-trigger channel. For some MEG systems this</span>
<span class="sd">            is separate from the stim channel.</span>
<span class="sd">        chpi : bool</span>
<span class="sd">            If True include continuous HPI coil channels.</span>
<span class="sd">        exci : bool</span>
<span class="sd">            Flux excitation channel used to be a stimulus channel.</span>
<span class="sd">        ias : bool</span>
<span class="sd">            Internal Active Shielding data (maybe on Triux only).</span>
<span class="sd">        syst : bool</span>
<span class="sd">            System status channel information (on Triux systems only).</span>
<span class="sd">        seeg : bool</span>
<span class="sd">            Stereotactic EEG channels.</span>
<span class="sd">        dipole : bool</span>
<span class="sd">            Dipole time course channels.</span>
<span class="sd">        gof : bool</span>
<span class="sd">            Dipole goodness of fit channels.</span>
<span class="sd">        bio : bool</span>
<span class="sd">            Bio channels.</span>
<span class="sd">        ecog : bool</span>
<span class="sd">            Electrocorticography channels.</span>
<span class="sd">        fnirs : bool | str</span>
<span class="sd">            Functional near-infrared spectroscopy channels. If True include all</span>
<span class="sd">            fNIRS channels. If False (default) include none. If string it can</span>
<span class="sd">            be &#39;hbo&#39; (to include channels measuring oxyhemoglobin) or &#39;hbr&#39; (to</span>
<span class="sd">            include channels measuring deoxyhemoglobin).</span>
<span class="sd">        include : list of string</span>
<span class="sd">            List of additional channels to include. If empty do not include</span>
<span class="sd">            any.</span>
<span class="sd">        exclude : list of string | str</span>
<span class="sd">            List of channels to exclude. If &#39;bads&#39; (default), exclude channels</span>
<span class="sd">            in ``info[&#39;bads&#39;]``.</span>
<span class="sd">        selection : list of string</span>
<span class="sd">            Restrict sensor channels (MEG, EEG) to this list of channel names.</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pick_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="n">meg</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="n">eeg</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="n">stim</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="n">eog</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="n">ecg</span><span class="p">,</span> <span class="n">emg</span><span class="o">=</span><span class="n">emg</span><span class="p">,</span>
            <span class="n">ref_meg</span><span class="o">=</span><span class="n">ref_meg</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="n">misc</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="n">resp</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="n">chpi</span><span class="p">,</span> <span class="n">exci</span><span class="o">=</span><span class="n">exci</span><span class="p">,</span>
            <span class="n">ias</span><span class="o">=</span><span class="n">ias</span><span class="p">,</span> <span class="n">syst</span><span class="o">=</span><span class="n">syst</span><span class="p">,</span> <span class="n">seeg</span><span class="o">=</span><span class="n">seeg</span><span class="p">,</span> <span class="n">dipole</span><span class="o">=</span><span class="n">dipole</span><span class="p">,</span> <span class="n">gof</span><span class="o">=</span><span class="n">gof</span><span class="p">,</span> <span class="n">bio</span><span class="o">=</span><span class="n">bio</span><span class="p">,</span>
            <span class="n">ecog</span><span class="o">=</span><span class="n">ecog</span><span class="p">,</span> <span class="n">fnirs</span><span class="o">=</span><span class="n">fnirs</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pick_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick some channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_names : list</span>
<span class="sd">            The list of channels to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        drop_channels</span>
<span class="sd">        pick_types</span>
<span class="sd">        reorder_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The channel names given are assumed to be a set, i.e. the order</span>
<span class="sd">        does not matter. The original order of the channels is preserved.</span>
<span class="sd">        You can use ``reorder_channels`` to set channel order if necessary.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span>
            <span class="n">pick_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">))</span>

    <span class="nd">@fill_doc</span>
    <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Pick a subset of channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(picks_all)s</span>
<span class="sd">        exclude : list | str</span>
<span class="sd">            Set of channels to exclude, only used when picking based on</span>
<span class="sd">            types (e.g., exclude=&quot;bads&quot; when picks=&quot;meg&quot;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="p">,</span>
                              <span class="n">allow_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_names : list</span>
<span class="sd">            The desired channel order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        drop_channels</span>
<span class="sd">        pick_types</span>
<span class="sd">        pick_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Channel names must be unique. Channels that are not in ``ch_names``</span>
<span class="sd">        are dropped.</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_excludes_includes</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel name repeated: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ch_name</span><span class="p">,))</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop channel(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ch_names : list or str</span>
<span class="sd">            List of channel name(s) or channel name to remove.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reorder_channels</span>
<span class="sd">        pick_channels</span>
<span class="sd">        pick_types</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;ch_names&#39; must be a list of strings, got &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;ch_names&#39; must be a list or a string, got &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)))</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Channel(s) </span><span class="si">{0}</span><span class="s2"> not found, nothing dropped.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)))</span>

        <span class="n">bad_idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_names</span>
                   <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)),</span> <span class="n">bad_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_drop_channels</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pick_drop_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c1"># avoid circular imports</span>
        <span class="kn">from</span> <span class="nn">..time_frequency</span> <span class="k">import</span> <span class="n">AverageTFR</span><span class="p">,</span> <span class="n">EpochsTFR</span>

        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adding, dropping, or reordering channels&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;picks&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cals&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">pick_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_projector&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="n">idx</span><span class="p">]</span>

        <span class="c1"># All others (Evoked, Epochs, Raw) have chs axis=-2</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">AverageTFR</span><span class="p">,</span> <span class="n">EpochsTFR</span><span class="p">))</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_list</span><span class="p">,</span> <span class="n">force_update_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append new channels to the instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_list : list</span>
<span class="sd">            A list of objects to append to self. Must contain all the same</span>
<span class="sd">            type as the current object</span>
<span class="sd">        force_update_info : bool</span>
<span class="sd">            If True, force the info for objects to be appended to match the</span>
<span class="sd">            values in `self`. This should generally only be used when adding</span>
<span class="sd">            stim channels for which important metadata won&#39;t be overwritten.</span>

<span class="sd">            .. versionadded:: 0.12</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        drop_channels</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``self`` is a Raw instance that has been preloaded into a</span>
<span class="sd">        :obj:`numpy.memmap` instance, the memmap will be resized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># avoid circular imports</span>
        <span class="kn">from</span> <span class="nn">..io</span> <span class="k">import</span> <span class="n">BaseRaw</span><span class="p">,</span> <span class="n">_merge_info</span>
        <span class="kn">from</span> <span class="nn">..epochs</span> <span class="k">import</span> <span class="n">BaseEpochs</span>

        <span class="n">_validate_type</span><span class="p">(</span><span class="n">add_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s1">&#39;Input&#39;</span><span class="p">)</span>

        <span class="c1"># Object-specific checks</span>
        <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]:</span>
            <span class="n">_check_preload</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s2">&quot;adding channels&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="n">BaseRaw</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="n">BaseEpochs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">con_axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comp_class</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span><span class="p">:</span>
            <span class="n">_validate_type</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">comp_class</span><span class="p">,</span> <span class="s1">&#39;All input&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">inst</span><span class="o">.</span><span class="n">_data</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">add_list</span><span class="p">]</span>

        <span class="c1"># Make sure that all dimensions other than channel axis are the same</span>
        <span class="n">compare_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">con_axis</span><span class="p">]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dat</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])[:,</span> <span class="n">compare_axes</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;All data dimensions except channels &#39;</span>
                                     <span class="s1">&#39;must match, got </span><span class="si">%s</span><span class="s1"> != </span><span class="si">%s</span><span class="s1">&#39;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">shapes</span>

        <span class="c1"># Create final data / info objects</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">inst</span><span class="o">.</span><span class="n">info</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">add_list</span><span class="p">]</span>
        <span class="n">new_info</span> <span class="o">=</span> <span class="n">_merge_info</span><span class="p">(</span><span class="n">infos</span><span class="p">,</span> <span class="n">force_update_to_first</span><span class="o">=</span><span class="n">force_update_info</span><span class="p">)</span>

        <span class="c1"># Now update the attributes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">)</span> <span class="ow">and</span> <span class="n">con_axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> \
                <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;darwin&#39;</span><span class="p">:</span>  <span class="c1"># resizing not available--no mremap</span>
            <span class="c1"># Use a resize and fill in other ones</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">),)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n_bytes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">,</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">out_shape</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">==</span> <span class="n">n_bytes</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">this_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">this_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">this_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">con_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">new_info</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s1">&#39;_cals&#39;</span><span class="p">)</span>
                                         <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">add_list</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">InterpolationMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Raw, Evoked, Epochs.&quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">interpolate_bads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reset_bads</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;accurate&#39;</span><span class="p">,</span>
                         <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate bad MEG and EEG channels.</span>

<span class="sd">        Operates in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reset_bads : bool</span>
<span class="sd">            If True, remove the bads from info.</span>
<span class="sd">        mode : str</span>
<span class="sd">            Either ``&#39;accurate&#39;`` or ``&#39;fast&#39;``, determines the quality of the</span>
<span class="sd">            Legendre polynomial expansion used for interpolation of MEG</span>
<span class="sd">            channels.</span>
<span class="sd">        origin : array-like, shape (3,) | str</span>
<span class="sd">            Origin of the sphere in the head coordinate frame and in meters.</span>
<span class="sd">            Can be ``&#39;auto&#39;``, which means a head-digitization-based origin</span>
<span class="sd">            fit. Default is ``(0., 0., 0.04)``.</span>

<span class="sd">            .. versionadded:: 0.17</span>
<span class="sd">        %(verbose_meth)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inst : instance of Raw, Epochs, or Evoked</span>
<span class="sd">            The modified instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.interpolation</span> <span class="k">import</span> <span class="n">_interpolate_bads_eeg</span><span class="p">,</span> <span class="n">_interpolate_bads_meg</span>

        <span class="n">_check_preload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;interpolation&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No bad channels to interpolate. Doing nothing...&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">_interpolate_bads_eeg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_interpolate_bads_meg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_bads</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">rename_channels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rename channels.</span>

<span class="sd">    .. warning::  The channel names must have at most 15 characters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        Measurement info.</span>
<span class="sd">    mapping : dict | callable</span>
<span class="sd">        a dictionary mapping the old channel to a new channel name</span>
<span class="sd">        e.g. {&#39;EEG061&#39; : &#39;EEG161&#39;}. Can also be a callable function</span>
<span class="sd">        that takes and returns a string (new in version 0.10.0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>
    <span class="n">bads</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">])</span>  <span class="c1"># make our own local copies</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span>

    <span class="c1"># first check and assemble clean mappings of index and name</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">orig_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">orig_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ch_names</span> <span class="k">for</span> <span class="n">orig_name</span> <span class="ow">in</span> <span class="n">orig_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel name(s) in mapping missing from info: &quot;</span>
                             <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orig_names</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">missing</span><span class="p">)])</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch_name</span><span class="p">),</span> <span class="n">new_name</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">ch_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
        <span class="n">new_names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ci</span><span class="p">,</span> <span class="n">mapping</span><span class="p">(</span><span class="n">ch_name</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mapping must be callable or dict, not </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mapping</span><span class="p">),))</span>

    <span class="c1"># check we got all strings out of the mapping</span>
    <span class="k">for</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">new_names</span><span class="p">:</span>
        <span class="n">_validate_type</span><span class="p">(</span><span class="n">new_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span> <span class="s1">&#39;New channel mappings&#39;</span><span class="p">)</span>

    <span class="n">bad_new_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new_names</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_new_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Channel names cannot be longer than 15 &#39;</span>
                         <span class="s1">&#39;characters. These channel names are not &#39;</span>
                         <span class="s1">&#39;valid : </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">new_names</span><span class="p">)</span>

    <span class="c1"># do the remapping locally</span>
    <span class="k">for</span> <span class="n">c_ind</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">new_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bads</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bad</span> <span class="o">==</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]:</span>
                <span class="n">bads</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="n">ch_names</span><span class="p">[</span><span class="n">c_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>

    <span class="c1"># check that all the channel names are unique</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New channel names are not unique, renaming failed&#39;</span><span class="p">)</span>

    <span class="c1"># do the remapping in info</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bads</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">],</span> <span class="n">ch_names</span><span class="p">):</span>
        <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;ch_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_name</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_update_redundant</span><span class="p">()</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_recursive_flatten</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unpack mat files in Python.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cell</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cell</span>


<span class="nd">@fill_doc</span>
<span class="k">def</span> <span class="nf">read_ch_connectivity</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse FieldTrip neighbors .mat file.</span>

<span class="sd">    More information on these neighbor definitions can be found on the related</span>
<span class="sd">    `FieldTrip documentation pages</span>
<span class="sd">    &lt;http://www.fieldtrip.org/template/neighbours&gt;`__.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The file name. Example: &#39;neuromag306mag&#39;, &#39;neuromag306planar&#39;,</span>
<span class="sd">        &#39;ctf275&#39;, &#39;biosemi64&#39;, etc.</span>
<span class="sd">    %(picks_all)s</span>
<span class="sd">        Picks Must match the template.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse.csr_matrix, shape (n_channels, n_channels)</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    ch_names : list</span>
<span class="sd">        The list of channel names present in connectivity matrix.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_ch_connectivity</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is closely related to :func:`find_ch_connectivity`. If you</span>
<span class="sd">    don&#39;t know the correct file for the neighbor definitions,</span>
<span class="sd">    :func:`find_ch_connectivity` can compute the connectivity matrix from 2d</span>
<span class="sd">    sensor locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.io</span> <span class="k">import</span> <span class="n">loadmat</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">templates_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span>
                                            <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;neighbors&#39;</span><span class="p">))</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">templates_dir</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">fname</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;_neighb.mat&#39;</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">+=</span> <span class="s1">&#39;_neighb.mat&#39;</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;I do not know about this neighbor &#39;</span>
                             <span class="s1">&#39;template: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">templates_dir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

    <span class="n">nb</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="s1">&#39;neighbours&#39;</span><span class="p">]</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="n">_recursive_flatten</span><span class="p">(</span><span class="n">nb</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">picks</span> <span class="o">=</span> <span class="n">_picks_to_idx</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">),</span> <span class="n">picks</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">_recursive_flatten</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
                 <span class="n">nb</span><span class="p">[</span><span class="s1">&#39;neighblabel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">_ch_neighbor_connectivity</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">)</span>
    <span class="c1"># picking before constructing matrix is buggy</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">picks</span><span class="p">][:,</span> <span class="n">picks</span><span class="p">]</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_names</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">ch_names</span>


<span class="k">def</span> <span class="nf">_ch_neighbor_connectivity</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute sensor connectivity matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        The channel names.</span>
<span class="sd">    neighbors : list of list</span>
<span class="sd">        A list of list of channel names. The neighbors to</span>
<span class="sd">        which the channels in ch_names are connected with.</span>
<span class="sd">        Must be of the same length as ch_names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse matrix</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`ch_names` and `neighbors` must &#39;</span>
                         <span class="s1">&#39;have the same length&#39;</span><span class="p">)</span>
    <span class="n">set_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">}</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">set_neighbors</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Some of your neighbors are not present in the &#39;</span>
                         <span class="s1">&#39;list of channel names&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`neighbors` must be a list of lists of str&#39;</span><span class="p">)</span>

    <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">neigbs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
        <span class="n">ch_connectivity</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">[</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">neigbs</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">ch_connectivity</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch_connectivity</span>


<span class="k">def</span> <span class="nf">find_ch_connectivity</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the connectivity matrix for the given channels.</span>

<span class="sd">    This function tries to infer the appropriate connectivity matrix template</span>
<span class="sd">    for the given channels. If a template is not found, the connectivity matrix</span>
<span class="sd">    is computed using Delaunay triangulation based on 2d sensor locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : instance of Info</span>
<span class="sd">        The measurement info.</span>
<span class="sd">    ch_type : str | None</span>
<span class="sd">        The channel type for computing the connectivity matrix. Currently</span>
<span class="sd">        supports &#39;mag&#39;, &#39;grad&#39;, &#39;eeg&#39; and None. If None, the info must contain</span>
<span class="sd">        only one channel type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse.csr_matrix, shape (n_channels, n_channels)</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    ch_names : list</span>
<span class="sd">        The list of channel names present in connectivity matrix.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    read_ch_connectivity</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.15</span>

<span class="sd">    Automatic detection of an appropriate connectivity matrix template only</span>
<span class="sd">    works for MEG data at the moment. This means that the connectivity matrix</span>
<span class="sd">    is always computed for EEG data and never loaded from a template file. If</span>
<span class="sd">    you want to load a template for a given montage use</span>
<span class="sd">    :func:`read_ch_connectivity` directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ch_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">channel_indices_by_type</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;info must contain only one channel type if &#39;</span>
                             <span class="s1">&#39;ch_type is None.&#39;</span><span class="p">)</span>
        <span class="n">ch_type</span> <span class="o">=</span> <span class="n">channel_type</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_check_option</span><span class="p">(</span><span class="s1">&#39;ch_type&#39;</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;mag&#39;</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">,</span> <span class="s1">&#39;eeg&#39;</span><span class="p">])</span>
    <span class="p">(</span><span class="n">has_vv_mag</span><span class="p">,</span> <span class="n">has_vv_grad</span><span class="p">,</span> <span class="n">is_old_vv</span><span class="p">,</span> <span class="n">has_4D_mag</span><span class="p">,</span> <span class="n">ctf_other_types</span><span class="p">,</span>
     <span class="n">has_CTF_grad</span><span class="p">,</span> <span class="n">n_kit_grads</span><span class="p">,</span> <span class="n">has_any_meg</span><span class="p">,</span> <span class="n">has_eeg_coils</span><span class="p">,</span>
     <span class="n">has_eeg_coils_and_meg</span><span class="p">,</span> <span class="n">has_eeg_coils_only</span><span class="p">,</span>
     <span class="n">has_neuromag_122_grad</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_ch_info</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="n">conn_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">has_vv_mag</span> <span class="ow">and</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;neuromag306mag&#39;</span>
    <span class="k">elif</span> <span class="n">has_vv_grad</span> <span class="ow">and</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;grad&#39;</span><span class="p">:</span>
        <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;neuromag306planar&#39;</span>
    <span class="k">elif</span> <span class="n">has_neuromag_122_grad</span><span class="p">:</span>
        <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;neuromag122&#39;</span>
    <span class="k">elif</span> <span class="n">has_4D_mag</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;MEG 248&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;MEG 248&#39;</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_GRAD</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_MAG</span>
            <span class="k">if</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;grad&#39;</span> <span class="ow">and</span> <span class="n">grad</span><span class="p">:</span>
                <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;bti248grad&#39;</span>
            <span class="k">elif</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span> <span class="ow">and</span> <span class="n">mag</span><span class="p">:</span>
                <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;bti248&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;MEG 148&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;MEG 148&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_MAG</span><span class="p">:</span>
                <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;bti148&#39;</span>
    <span class="k">elif</span> <span class="n">has_CTF_grad</span> <span class="ow">and</span> <span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;ctf64&#39;</span>
        <span class="k">elif</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;ctf275&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn_name</span> <span class="o">=</span> <span class="s1">&#39;ctf151&#39;</span>

    <span class="k">if</span> <span class="n">conn_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading connectivity matrix for </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">conn_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">read_ch_connectivity</span><span class="p">(</span><span class="n">conn_name</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Could not find a connectivity matrix for the data. &#39;</span>
                <span class="s1">&#39;Computing connectivity based on Delaunay triangulations.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_compute_ch_connectivity</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_ch_connectivity</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ch_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute channel connectivity matrix using Delaunay triangulations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : instance of mne.measuerment_info.Info</span>
<span class="sd">        The measurement info.</span>
<span class="sd">    ch_type : str</span>
<span class="sd">        The channel type for computing the connectivity matrix. Currently</span>
<span class="sd">        supports &#39;mag&#39;, &#39;grad&#39; and &#39;eeg&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ch_connectivity : scipy.sparse matrix, shape (n_channels, n_channels)</span>
<span class="sd">        The connectivity matrix.</span>
<span class="sd">    ch_names : list</span>
<span class="sd">        The list of channel names present in connectivity matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">spatial_tris_connectivity</span>
    <span class="kn">from</span> <span class="nn">..channels.layout</span> <span class="k">import</span> <span class="n">_auto_topomap_coords</span><span class="p">,</span> <span class="n">_pair_grad_sensors</span>
    <span class="n">combine_grads</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch_type</span> <span class="o">==</span> <span class="s1">&#39;grad&#39;</span> <span class="ow">and</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_PLANAR_T1</span> <span class="ow">in</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]]))</span>

    <span class="n">picks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_picks_by_type</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[]))[</span><span class="n">ch_type</span><span class="p">]</span>
    <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">][</span><span class="n">pick</span><span class="p">]</span> <span class="k">for</span> <span class="n">pick</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">combine_grads</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">_pair_grad_sensors</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">topomap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot find a pair for some of the &#39;</span>
                               <span class="s1">&#39;gradiometers. Cannot compute connectivity &#39;</span>
                               <span class="s1">&#39;matrix.&#39;</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">_auto_topomap_coords</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># only for one of the pair</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">_auto_topomap_coords</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">)</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">spatial_tris_connectivity</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">combine_grads</span><span class="p">:</span>
        <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">neigbs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">col</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># make sure each pair is included</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">ch_connectivity</span><span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ii</span><span class="p">,</span> <span class="n">neigbs</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ch_connectivity</span><span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ii</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># pair</span>
        <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">ch_connectivity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">ch_connectivity</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ch_connectivity</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ch_connectivity</span> <span class="o">=</span> <span class="n">ch_connectivity</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ch_connectivity</span><span class="p">,</span> <span class="n">ch_names</span>


<span class="k">def</span> <span class="nf">fix_mag_coil_types</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fix magnetometer coil types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        The info dict to correct. Corrections are done in-place.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function changes magnetometer coil types 3022 (T1: SQ20483N) and</span>
<span class="sd">    3023 (T2: SQ20483-A) to 3024 (T3: SQ20950N) in the channel definition</span>
<span class="sd">    records in the info structure.</span>

<span class="sd">    Neuromag Vectorview systems can contain magnetometers with two</span>
<span class="sd">    different coil sizes (3022 and 3023 vs. 3024). The systems</span>
<span class="sd">    incorporating coils of type 3024 were introduced last and are used at</span>
<span class="sd">    the majority of MEG sites. At some sites with 3024 magnetometers,</span>
<span class="sd">    the data files have still defined the magnetometers to be of type</span>
<span class="sd">    3022 to ensure compatibility with older versions of Neuromag software.</span>
<span class="sd">    In the MNE software as well as in the present version of Neuromag</span>
<span class="sd">    software coil type 3024 is fully supported. Therefore, it is now safe</span>
<span class="sd">    to upgrade the data files to use the true coil type.</span>

<span class="sd">    .. note:: The effect of the difference between the coil sizes on the</span>
<span class="sd">              current estimates computed by the MNE software is very small.</span>
<span class="sd">              Therefore the use of mne_fix_mag_coil_types is not mandatory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">old_mag_inds</span> <span class="o">=</span> <span class="n">_get_T1T2_mag_inds</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">old_mag_inds</span><span class="p">:</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">][</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T3</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> of </span><span class="si">%d</span><span class="s1"> T1/T2 magnetometer types replaced with T3.&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_mag_inds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pick_types</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">))))</span>
    <span class="n">info</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_T1T2_mag_inds</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find T1/T2 magnetometer coil types.&quot;&quot;&quot;</span>
    <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
    <span class="n">old_mag_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T1</span><span class="p">,</span>
                               <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T2</span><span class="p">):</span>
            <span class="n">old_mag_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old_mag_inds</span>


<span class="k">def</span> <span class="nf">_get_ch_info</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get channel info for inferring acquisition device.&quot;&quot;&quot;</span>
    <span class="n">chs</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">]</span>
    <span class="c1"># Only take first 16 bits, as higher bits store CTF comp order</span>
    <span class="n">coil_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chs</span><span class="p">}</span>
    <span class="n">channel_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chs</span><span class="p">}</span>

    <span class="n">has_vv_mag</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">coil_types</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                     <span class="p">[</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T1</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T2</span><span class="p">,</span>
                      <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_MAG_T3</span><span class="p">])</span>
    <span class="n">has_vv_grad</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">coil_types</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_PLANAR_T1</span><span class="p">,</span>
                                                <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_PLANAR_T2</span><span class="p">,</span>
                                                <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_VV_PLANAR_T3</span><span class="p">])</span>
    <span class="n">has_neuromag_122_grad</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">coil_types</span>
                                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_NM_122</span><span class="p">])</span>

    <span class="n">is_old_vv</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">chs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;ch_name&#39;</span><span class="p">]</span>

    <span class="n">has_4D_mag</span> <span class="o">=</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_MAGNES_MAG</span> <span class="ow">in</span> <span class="n">coil_types</span>
    <span class="n">ctf_other_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_REF_MAG</span><span class="p">,</span>
                       <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_REF_GRAD</span><span class="p">,</span>
                       <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_OFFDIAG_REF_GRAD</span><span class="p">)</span>
    <span class="n">has_CTF_grad</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_CTF_GRAD</span> <span class="ow">in</span> <span class="n">coil_types</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_MEG_CH</span> <span class="ow">in</span> <span class="n">channel_types</span> <span class="ow">and</span>
                     <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">ctf_other_types</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coil_types</span><span class="p">)))</span>
    <span class="c1"># hack due to MNE-C bug in IO of CTF</span>
    <span class="c1"># only take first 16 bits, as higher bits store CTF comp order</span>
    <span class="n">n_kit_grads</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;coil_type&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_KIT_GRAD</span>
                      <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chs</span><span class="p">)</span>

    <span class="n">has_any_meg</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">has_vv_mag</span><span class="p">,</span> <span class="n">has_vv_grad</span><span class="p">,</span> <span class="n">has_4D_mag</span><span class="p">,</span> <span class="n">has_CTF_grad</span><span class="p">,</span>
                       <span class="n">n_kit_grads</span><span class="p">])</span>
    <span class="n">has_eeg_coils</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_COIL_EEG</span> <span class="ow">in</span> <span class="n">coil_types</span> <span class="ow">and</span>
                     <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_EEG_CH</span> <span class="ow">in</span> <span class="n">channel_types</span><span class="p">)</span>
    <span class="n">has_eeg_coils_and_meg</span> <span class="o">=</span> <span class="n">has_eeg_coils</span> <span class="ow">and</span> <span class="n">has_any_meg</span>
    <span class="n">has_eeg_coils_only</span> <span class="o">=</span> <span class="n">has_eeg_coils</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_any_meg</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">has_vv_mag</span><span class="p">,</span> <span class="n">has_vv_grad</span><span class="p">,</span> <span class="n">is_old_vv</span><span class="p">,</span> <span class="n">has_4D_mag</span><span class="p">,</span> <span class="n">ctf_other_types</span><span class="p">,</span>
            <span class="n">has_CTF_grad</span><span class="p">,</span> <span class="n">n_kit_grads</span><span class="p">,</span> <span class="n">has_any_meg</span><span class="p">,</span> <span class="n">has_eeg_coils</span><span class="p">,</span>
            <span class="n">has_eeg_coils_and_meg</span><span class="p">,</span> <span class="n">has_eeg_coils_only</span><span class="p">,</span> <span class="n">has_neuromag_122_grad</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_1020_channel_selections</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">midline</span><span class="o">=</span><span class="s2">&quot;z&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return dict mapping from ROI names to lists of picks for 10/20 setups.</span>

<span class="sd">    This passes through all channel names, and uses a simple heuristic to</span>
<span class="sd">    separate channel names into three Region of Interest-based selections:</span>
<span class="sd">    Left, Midline and Right. The heuristic is that channels ending on any of</span>
<span class="sd">    the characters in `midline` are filed under that heading, otherwise those</span>
<span class="sd">    ending in odd numbers under &quot;Left&quot;, those in even numbers under &quot;Right&quot;.</span>
<span class="sd">    Other channels are ignored. This is appropriate for 10/20 files, but not</span>
<span class="sd">    for other channel naming conventions.</span>
<span class="sd">    If an info object is provided, lists are sorted from posterior to anterior.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : instance of Info</span>
<span class="sd">        Where to obtain the channel names from. The picks will</span>
<span class="sd">        be in relation to the position in `info[&quot;ch_names&quot;]`. If possible, this</span>
<span class="sd">        lists will be sorted by y value position of the channel locations,</span>
<span class="sd">        i.e., from back to front.</span>
<span class="sd">    midline : str</span>
<span class="sd">        Names ending in any of these characters are stored under the `Midline`</span>
<span class="sd">        key. Defaults to &#39;z&#39;. Note that capitalization is ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    selections : dict</span>
<span class="sd">        A dictionary mapping from ROI names to lists of picks (integers).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_validate_type</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">.layout</span> <span class="k">import</span> <span class="n">find_layout</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">find_layout</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">layout</span><span class="o">.</span><span class="n">names</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>  <span class="c1"># no channel positions found</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;ch_names&quot;</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">selections</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Left</span><span class="o">=</span><span class="p">[],</span> <span class="n">Midline</span><span class="o">=</span><span class="p">[],</span> <span class="n">Right</span><span class="o">=</span><span class="p">[])</span>
    <span class="k">for</span> <span class="n">pick</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_names</span><span class="p">):</span>
        <span class="n">last_char</span> <span class="o">=</span> <span class="n">channel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># in 10/20, last char codes hemisphere</span>
        <span class="k">if</span> <span class="n">last_char</span> <span class="ow">in</span> <span class="n">midline</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="s2">&quot;Midline&quot;</span>
        <span class="k">elif</span> <span class="n">last_char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="s2">&quot;Left&quot;</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_char</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;Right&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># ignore the channel</span>
            <span class="k">continue</span>
        <span class="n">selections</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pick</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># sort channels from front to center</span>
        <span class="c1"># (y-coordinate of the position info in the layout)</span>
        <span class="n">selections</span> <span class="o">=</span> <span class="p">{</span><span class="n">selection</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">picks</span><span class="p">)[</span><span class="n">pos</span><span class="p">[</span><span class="n">picks</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
                      <span class="k">for</span> <span class="n">selection</span><span class="p">,</span> <span class="n">picks</span> <span class="ow">in</span> <span class="n">selections</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">return</span> <span class="n">selections</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-05-21

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>